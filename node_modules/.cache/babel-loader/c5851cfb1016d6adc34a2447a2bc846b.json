{"remainingRequest":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\thread-loader\\dist\\cjs.js!E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\babel-loader\\lib\\index.js!E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\src\\components\\content.vue?vue&type=script&lang=js&","dependencies":[{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\src\\components\\content.vue","mtime":1620753042660},{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620651810122},{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1620651802084},{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\babel-loader\\lib\\index.js","mtime":1620651842149},{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620651810122},{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\vue-loader\\lib\\index.js","mtime":1620651837901}],"contextDependencies":[],"result":["import _typeof from \"E:\\\\\\u7EC3\\u4E60\\\\\\u5BFC\\u5E08\\u9879\\u76EE\\\\\\u5206\\u522B\\u57FA\\u4E8EJquery\\u548Cvue.cli\\u7CFB\\u7EDF\\u76842048\\u5C0F\\u6E38\\u620F\\\\2048\\uFF08vue\\uFF09\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/typeof\";\nimport \"core-js/modules/es6.array.filter\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.array.find-index\";\nimport \"core-js/modules/es6.array.find\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport Background from \"../components/background.vue\";\nexport default {\n  name: 'Home',\n  components: {\n    Background: Background\n  },\n  data: function data() {\n    return {\n      score: 0,\n      numberCells: [],\n      color: {\n        2: '#eee4da',\n        4: '#ede0c8',\n        8: '#f2b179',\n        16: '#f59563',\n        32: '#f67c5f',\n        64: '#f65e3b',\n        128: '#edcf72',\n        256: '#edcc61',\n        512: '#0444BF',\n        1024: '#A79674',\n        2048: '#282726',\n        4096: '#280b21',\n        8192: '#281d04'\n      },\n      auxId: 0,\n      success: false,\n      gameover: false,\n      canMove: true\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.init();\n    document.addEventListener('keyup', function (event) {\n      if (!_this.canMove) {\n        return;\n      }\n\n      switch (event.keyCode) {\n        case 38:\n          _this.moveUp();\n\n          _this.success = _this.isSuccess();\n          _this.gameover = _this.isGameOver();\n          break;\n\n        case 40:\n          _this.moveDown();\n\n          _this.success = _this.isSuccess();\n          _this.gameover = _this.isGameOver();\n          break;\n\n        case 37:\n          _this.moveLeft();\n\n          _this.success = _this.isSuccess();\n          _this.gameover = _this.isGameOver();\n          break;\n\n        case 39:\n          _this.moveRight();\n\n          _this.success = _this.isSuccess();\n          _this.gameover = _this.isGameOver();\n          break;\n      }\n    });\n  },\n  methods: {\n    //初始化游戏\n    init: function init() {\n      this.numberCells.length = 0;\n      this.score = 0;\n      this.auxId = 0;\n      this.success = false;\n      this.gameover = false;\n      this.generateOneNumberCell();\n      this.generateOneNumberCell();\n    },\n\n    /* 先随机生成一个2或4的数字，然后随机获得0-3的坐标值，\n    再去判断当前生成的坐标上有没有其他格子，若有则继续随机\n    生成直至找到一个空位，然后再push到数组中 */\n    generateOneNumberCell: function generateOneNumberCell() {\n      var _this2 = this;\n\n      if (this.isFull()) {\n        return;\n      }\n\n      var num = this.random24();\n      var newCell = {\n        //创建一个上层单元格对象\n        x: this.random0123(),\n        y: this.random0123(),\n        num: num,\n        color: this.color[num],\n        id: this.auxId++\n      };\n\n      var isExist = function isExist() {\n        return _this2.getCellByPoint({\n          x: newCell.x,\n          y: newCell.y\n        });\n      };\n\n      while (isExist()) {\n        newCell.x = this.random0123();\n        newCell.y = this.random0123();\n      }\n\n      this.numberCells.push(newCell);\n    },\n    //随机产生2或4\n    random24: function random24() {\n      //70%概率是2\n      return Math.random() <= 0.7 ? 2 : 4;\n    },\n    random0123: function random0123() {\n      return parseInt(Math.random() * 4);\n    },\n    getCellByPoint: function getCellByPoint(_ref) {\n      var x = _ref.x,\n          y = _ref.y;\n      return this.numberCells.find(function (cell) {\n        return cell.x === x && cell.y === y;\n      });\n    },\n    getTop: function getTop(cell) {\n      return \"\".concat(20 + cell.y * 120, \"px\");\n    },\n    getLeft: function getLeft(cell) {\n      return \"\".concat(20 + cell.x * 120, \"px\");\n    },\n    sortByX: function sortByX(a, b) {\n      return a.x - b.x;\n    },\n    sortByY: function sortByY(a, b) {\n      return a.y - b.y;\n    },\n    getIndexById: function getIndexById(id) {\n      return this.numberCells.findIndex(function (cell) {\n        return cell.id === id;\n      });\n    },\n    //单元格合并动画\n    animateMerge: function animateMerge(dom) {\n      dom.animate([{\n        transform: 'scale(0)'\n      }, {\n        transform: 'scale(1.2)'\n      }, {\n        transform: 'scale(1)'\n      }], {\n        duration: 150\n      }); //合并后可以接受键盘输入\n\n      this.canMove = true;\n    },\n    moveLeft: function moveLeft() {\n      var _this3 = this;\n\n      //一个表示可以向左移动的变量\n      var canMoveLeft = false;\n\n      var _loop = function _loop(i) {\n        //按顺序获得该行的数字格\n        var row = _this3.numberCells.filter(function (cell) {\n          return cell.y === i;\n        }).sort(_this3.sortByX); //一个表示上一格已经过合并的变量\n\n\n        var visited = false;\n\n        var _loop2 = function _loop2(_j) {\n          //如果当前是第一个数字格，则其左边一定没有数字格，则直接推向最左边\n          if (_j === 0) {\n            //如果已经在最左边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最左边则移动\n            if (row[_j].x !== 0) {\n              row[_j].x = 0;\n              canMoveLeft = true;\n            }\n          } else {\n            //如果当前数字格与上一数字格的数字一样，则合并\n            //否则就是将其挪到上一格的后一列，条件是上一格的后一列不为当前格\n            if (row[_j].num === row[_j - 1].num && !visited) {\n              //移动当前数字格的坐标到上一数字格上\n              row[_j].x = row[_j - 1].x; //滑动中禁止键盘输入\n\n              _this3.canMove = false; //获取当前数字格的DOM\n\n              var dom1 = document.querySelector(\"#c\".concat(row[_j].id)); //给当前数字格一个监听器，在动画结束后再更新合并后的数字格\n\n              dom1.addEventListener('transitionend', function () {\n                var newNum = row[_j].num * 2;\n                row[_j - 1].num = newNum;\n                row[_j - 1].color = _this3.color[newNum];\n                var dom2 = document.querySelector(\"#c\".concat(row[_j - 1].id));\n\n                _this3.animateMerge(dom2);\n\n                _this3.numberCells.splice(_this3.getIndexById(row[_j].id), 1);\n\n                row.splice(_j, 1);\n                _j--;\n                _this3.score += newNum;\n              }, true); //若发生合并则表示当前可以向左移动，则表示这一格已进行合并，避免重复合并\n\n              canMoveLeft = true;\n              visited = true; // const newNum = row[j].num * 2;\n              // row[j - 1].num = newNum;\n              // row[j - 1].color = this.color[newNum];\n              // this.numberCells.splice(this.getIndexById(row[j].id), 1);\n              // row.splice(j, 1);\n              // j--;\n              // canMoveLeft = true;\n              // visited = true;\n              // this.score += newNum;\n            } else {\n              if (row[_j].x !== row[_j - 1].x + 1) {\n                row[_j].x = row[_j - 1].x + 1;\n                canMoveLeft = true; //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n\n                visited = false;\n              }\n            }\n          }\n\n          j = _j;\n        };\n\n        for (var j = 0; j < row.length; j++) {\n          _loop2(j);\n        }\n      };\n\n      for (var i = 0; i < 4; i++) {\n        _loop(i);\n      }\n\n      if (canMoveLeft) {\n        this.generateOneNumberCell();\n      }\n    },\n    moveRight: function moveRight() {\n      var _this4 = this;\n\n      //一个表示可以向右移动的变量\n      var canMoveRight = false;\n\n      var _loop3 = function _loop3(i) {\n        //按顺序获得该行的数字格\n        var row = _this4.numberCells.filter(function (cell) {\n          return cell.y === i;\n        }).sort(_this4.sortByX); //一个表示上一格已经过合并的变量\n\n\n        var visited = false;\n\n        var _loop4 = function _loop4(_j2) {\n          //如果当前是最后一个数字格，则其右边一定没有数字格，则直接推向最右边\n          if (_j2 === row.length - 1) {\n            //如果已经在最右边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最右边则移动\n            if (row[_j2].x !== 3) {\n              row[_j2].x = 3;\n              canMoveRight = true;\n            }\n          } else {\n            //如果当前数字格与后一数字格的数字一样，则合并\n            //否则就是将其挪到后一格的前一列，条件是后一格的前一列不为当前格\n            if (row[_j2].num === row[_j2 + 1].num && !visited) {\n              row[_j2].x = row[_j2 + 1].x; //滑动中禁止键盘输入\n\n              _this4.canMove = false;\n              var dom1 = document.querySelector(\"#c\".concat(row[_j2].id));\n              dom1.addEventListener('transitionend', function () {\n                var newNum = row[_j2].num * 2;\n                row[_j2 + 1].num = newNum;\n                row[_j2 + 1].color = _this4.color[newNum];\n                var dom2 = document.querySelector(\"#c\".concat(row[_j2 + 1].id));\n\n                _this4.animateMerge(dom2);\n\n                _this4.numberCells.splice(_this4.getIndexById(row[_j2].id), 1);\n\n                row.splice(_j2, 1);\n                _this4.score += newNum;\n              }, true);\n              canMoveRight = true;\n              visited = true;\n            } else {\n              if (row[_j2].x !== row[_j2 + 1].x - 1) {\n                row[_j2].x = row[_j2 + 1].x - 1;\n                canMoveRight = true; //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n\n                visited = false;\n              }\n            }\n          }\n        };\n\n        for (var _j2 = row.length - 1; _j2 >= 0; _j2--) {\n          _loop4(_j2);\n        }\n      };\n\n      for (var i = 0; i < 4; i++) {\n        _loop3(i);\n      }\n\n      if (canMoveRight) {\n        this.generateOneNumberCell();\n      }\n    },\n    moveUp: function moveUp() {\n      var _this5 = this;\n\n      //一个表示可以向上移动的变量\n      var canMoveUp = false;\n\n      var _loop5 = function _loop5(i) {\n        //按顺序获得该列的数字格\n        var column = _this5.numberCells.filter(function (cell) {\n          return cell.x === i;\n        }).sort(_this5.sortByY); //一个表示上一格已经过合并的变量\n\n\n        var visited = false;\n\n        var _loop6 = function _loop6(_j4) {\n          //如果当前是第一个数字格，则其上边一定没有数字格，则直接推向最上边\n          if (_j4 === 0) {\n            //如果已经在最上边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最上边则移动\n            if (column[_j4].y !== 0) {\n              column[_j4].y = 0;\n              canMoveUp = true;\n            }\n          } else {\n            //如果当前数字格与上一数字格的数字一样，则合并\n            //否则就是将其挪到上一格的后一行，条件是上一格的后一行不为当前格\n            if (column[_j4].num === column[_j4 - 1].num && !visited) {\n              column[_j4].y = column[_j4 - 1].y; //滑动中禁止键盘输入\n\n              _this5.canMove = false;\n              var dom1 = document.querySelector(\"#c\".concat(column[_j4].id));\n              dom1.addEventListener('transitionend', function () {\n                var newNum = column[_j4].num * 2;\n                column[_j4 - 1].num = newNum;\n                column[_j4 - 1].color = _this5.color[newNum];\n                var dom2 = document.querySelector(\"#c\".concat(column[_j4 - 1].id));\n\n                _this5.animateMerge(dom2);\n\n                _this5.numberCells.splice(_this5.getIndexById(column[_j4].id), 1);\n\n                column.splice(_j4, 1);\n                _j4--;\n                _this5.score += newNum;\n              }, true);\n              canMoveUp = true;\n              visited = true;\n            } else {\n              if (column[_j4].y !== column[_j4 - 1].y + 1) {\n                column[_j4].y = column[_j4 - 1].y + 1;\n                canMoveUp = true; //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n\n                visited = false;\n              }\n            }\n          }\n\n          _j3 = _j4;\n        };\n\n        for (var _j3 = 0; _j3 < column.length; _j3++) {\n          _loop6(_j3);\n        }\n      };\n\n      for (var i = 0; i < 4; i++) {\n        _loop5(i);\n      }\n\n      if (canMoveUp) {\n        this.generateOneNumberCell();\n      }\n    },\n    moveDown: function moveDown() {\n      var _this6 = this;\n\n      //一个表示可以向下移动的变量\n      var canMoveDown = false;\n\n      var _loop7 = function _loop7(i) {\n        //按顺序获得该列的数字格\n        var column = _this6.numberCells.filter(function (cell) {\n          return cell.x === i;\n        }).sort(_this6.sortByY); //一个表示上一格已经过合并的变量\n\n\n        var visited = false;\n\n        var _loop8 = function _loop8(_j5) {\n          //如果当前是最后一个数字格，则其下边一定没有数字格，则直接推向最下边\n          if (_j5 === column.length - 1) {\n            //如果已经在最后边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最后边则移动\n            if (column[_j5].y !== 3) {\n              column[_j5].y = 3;\n              canMoveDown = true;\n            }\n          } else {\n            //如果当前数字格与下一数字格的数字一样，则合并\n            //否则就是将其挪到下一格的前一行，条件是下一格的前一行不为当前格\n            if (column[_j5].num === column[_j5 + 1].num && !visited) {\n              column[_j5].y = column[_j5 + 1].y; //滑动中禁止键盘输入\n\n              _this6.canMove = false;\n              var dom1 = document.querySelector(\"#c\".concat(column[_j5].id));\n              dom1.addEventListener('transitionend', function () {\n                var newNum = column[_j5].num * 2;\n                column[_j5 + 1].num = newNum;\n                column[_j5 + 1].color = _this6.color[newNum];\n                var dom2 = document.querySelector(\"#c\".concat(column[_j5 + 1].id));\n\n                _this6.animateMerge(dom2);\n\n                _this6.numberCells.splice(_this6.getIndexById(column[_j5].id), 1);\n\n                column.splice(_j5, 1);\n                _this6.score += newNum;\n              }, true);\n              canMoveDown = true;\n              visited = true;\n            } else {\n              if (column[_j5].y !== column[_j5 + 1].y - 1) {\n                column[_j5].y = column[_j5 + 1].y - 1;\n                canMoveDown = true; //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n\n                visited = false;\n              }\n            }\n          }\n        };\n\n        for (var _j5 = column.length - 1; _j5 >= 0; _j5--) {\n          _loop8(_j5);\n        }\n      };\n\n      for (var i = 0; i < 4; i++) {\n        _loop7(i);\n      }\n\n      if (canMoveDown) {\n        this.generateOneNumberCell();\n      }\n    },\n    isFull: function isFull() {\n      return this.numberCells.length > 15;\n    },\n    isSuccess: function isSuccess() {\n      return !!this.numberCells.find(function (cell) {\n        return cell.num === 8192;\n      });\n    },\n    isGameOver: function isGameOver() {\n      var _this7 = this;\n\n      //判断是否可以移动\n      //思路是看每个格子的右边或下边的格子是否与自己的数值相等\n      //因此第四行已经经过了第三行的比较，不用再向下比较\n      //第四列的已经经过第三列的比较，不用再向右比较\n      var cannotMove = function cannotMove() {\n        var _loop9 = function _loop9(i) {\n          var row = _this7.numberCells.filter(function (cell) {\n            return cell.y === i;\n          }).sort(_this7.sortByX);\n\n          for (var _j6 = 0; _j6 < 4; _j6++) {\n            //除第四行外，所有格子跟下一行同一列的格子比较数值是否相等\n            if (i < 3) {\n              if (row[_j6].num === _this7.getCellByPoint({\n                x: _j6,\n                y: i + 1\n              }).num) {\n                return {\n                  v: false\n                };\n              }\n            } //除第四列外，所有格子跟同一行下一列的格子比较数值是否相等\n\n\n            if (_j6 < 3) {\n              if (row[_j6].num === row[_j6 + 1].num) {\n                return {\n                  v: false\n                };\n              }\n            }\n          }\n        };\n\n        for (var i = 0; i < 4; i++) {\n          var _ret = _loop9(i);\n\n          if (_typeof(_ret) === \"object\") return _ret.v;\n        }\n\n        return true;\n      };\n\n      return this.isFull() && cannotMove();\n    }\n  }\n};",{"version":3,"sources":["content.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\r\n\t<div class=\"home\">\r\n\t\t<div class=\"header\">\r\n\t\t\t<h1>2048</h1>\r\n\t\t\t<div class=\"button\">\r\n\t\t\t\t<button class=\"init-button\">\r\n\t\t\t\t  Score: <span>{{ score }}</span>\r\n\t\t\t\t</button>\r\n\t\t\t\t<button @click=\"init\" class=\"init-button\">New Game</button>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t<div class=\"container\">\r\n\t\t\t<div class=\"mask\" v-if=\"success\">\r\n\t\t\t\t<h1>You win!</h1>\r\n\t\t\t\t<button @click=\"init\" class=\"init-button\">Try again</button>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"mask\" v-if=\"gameover\">\r\n\t\t\t\t<h1>Game over!</h1>\r\n\t\t\t\t<button @click=\"init\" class=\"init-button\">Try again</button>\r\n\t\t\t</div>\r\n\t\t\t<Background></Background>\r\n\t\t\t<div class=\"number-cells\">\r\n\t\t\t\t<transition-group name=\"appear\">\r\n\t\t\t\t<div\r\n\t\t\t\t\tclass=\"number-cell\"\r\n\t\t\t\t\tv-for=\"cell of numberCells\"\r\n\t\t\t\t\t:id=\"`c${cell.id}`\"\r\n\t\t\t\t\t:key=\"cell.id\"\r\n\t\t\t\t\t:style=\"\r\n\t\t\t\t\t  `\r\n\t\t\t\t  width: 100px;\r\n\t\t\t\t  height: 100px;\r\n\t\t\t\t  border-radius: 5px;\r\n\t\t\t\t  font-size: 32px;\r\n\t\t\t\t  font-weight: bold;\r\n\t\t\t\t  line-height: 80px;\r\n\t\t\t\t  color: #776e65;\r\n\t\t\t\r\n\t\t\t\t  position: absolute;\r\n\t\t\t\t  z-index: ${cell.num};\r\n\t\t\t\t  backgroundColor: ${cell.color};\r\n\t\t\t\t  top: ${getTop(cell)};\r\n\t\t\t\t  left: ${getLeft(cell)};\r\n\t\t\t\t  `\r\n\t\t\t\t\t\"\r\n\t\t\t\t  > {{ cell.num }}\r\n\t\t\t\t  </div>\r\n\t\t\t\t</transition-group>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\n</template>\n\n<script>\r\n\timport Background from '../components/background.vue'\r\n\texport default {\r\n\t  name: 'Home',\r\n\t  components: {\r\n\t    Background,\r\n\t  },\r\n\t  data() {\r\n\t    return {\r\n\t      score: 0,\r\n\t      numberCells: [],\r\n\t      color: {\r\n\t        2: '#eee4da',\r\n\t        4: '#ede0c8',\r\n\t        8: '#f2b179',\r\n\t        16: '#f59563',\r\n\t        32: '#f67c5f',\r\n\t        64: '#f65e3b',\r\n\t        128: '#edcf72',\r\n\t        256: '#edcc61',\r\n\t        512: '#0444BF',\r\n\t        1024: '#A79674',\r\n\t        2048: '#282726',\r\n\t        4096: '#280b21',\r\n\t        8192: '#281d04',\r\n\t      },\r\n\t      auxId: 0,\r\n\t      success: false,\r\n\t      gameover: false,\r\n\t      canMove: true,\r\n\t    };\r\n\t  },\r\n\t  mounted() {\r\n\t    this.init();\r\n\t    document.addEventListener('keyup', (event) => {\r\n\t      if (!this.canMove) {\r\n\t        return;\r\n\t      }\r\n\t      switch (event.keyCode) {\r\n\t        case 38:\r\n\t          this.moveUp();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t        case 40:\r\n\t          this.moveDown();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t        case 37:\r\n\t          this.moveLeft();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t        case 39:\r\n\t          this.moveRight();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t      }\r\n\t    });\r\n\t  },\r\n\t  methods: {\r\n\t\t  //初始化游戏\r\n\t    init() {\r\n\t      this.numberCells.length = 0;\r\n\t      this.score = 0;\r\n\t      this.auxId = 0;\r\n\t      this.success = false;\r\n\t      this.gameover = false;\r\n\t      this.generateOneNumberCell();\r\n\t      this.generateOneNumberCell();\r\n\t    },\r\n\t\t\r\n\t\t\r\n\t\t/* 先随机生成一个2或4的数字，然后随机获得0-3的坐标值，\r\n\t\t再去判断当前生成的坐标上有没有其他格子，若有则继续随机\r\n\t\t生成直至找到一个空位，然后再push到数组中 */\r\n\t    generateOneNumberCell() {\r\n\t      if (this.isFull()) {\r\n\t        return;\r\n\t      }\r\n\t      const num = this.random24();\r\n\t      const newCell = {//创建一个上层单元格对象\r\n\t        x: this.random0123(),\r\n\t        y: this.random0123(),\r\n\t        num: num,\r\n\t        color: this.color[num],\r\n\t        id: this.auxId++,\r\n\t      };\r\n\t      let isExist = () => this.getCellByPoint({ x: newCell.x, y: newCell.y });\r\n\t      while (isExist()) {\r\n\t        newCell.x = this.random0123();\r\n\t        newCell.y = this.random0123();\r\n\t      }\r\n\t      this.numberCells.push(newCell);\r\n\t    },\r\n\t\t//随机产生2或4\r\n\t    random24() {\r\n\t      //70%概率是2\r\n\t      return Math.random() <= 0.7 ? 2 : 4;\r\n\t    },\r\n\t    random0123() {\r\n\t      return parseInt(Math.random() * 4);\r\n\t    },\r\n\t    getCellByPoint({ x, y }) {\r\n\t      return this.numberCells.find((cell) => cell.x === x && cell.y === y);\r\n\t    },\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t    getTop(cell) {\r\n\t      return `${20 + cell.y * 120}px`;\r\n\t    },\r\n\t    getLeft(cell) {\r\n\t      return `${20 + cell.x * 120}px`;\r\n\t    },\r\n\t    sortByX(a, b) {\r\n\t      return a.x - b.x;\r\n\t    },\r\n\t    sortByY(a, b) {\r\n\t      return a.y - b.y;\r\n\t    },\r\n\t    getIndexById(id) {\r\n\t      return this.numberCells.findIndex((cell) => cell.id === id);\r\n\t    },\r\n\t\t//单元格合并动画\r\n\t    animateMerge(dom) {\r\n\t      dom.animate(\r\n\t            [\r\n\t              { transform: 'scale(0)' },\r\n\t              { transform: 'scale(1.2)' },\r\n\t              { transform: 'scale(1)' },\r\n\t            ],\r\n\t            {\r\n\t              duration: 150,\r\n\t            }\r\n\t      );\r\n\t      //合并后可以接受键盘输入\r\n\t      this.canMove = true;\r\n\t    },\r\n\t    moveLeft() {\r\n\t      //一个表示可以向左移动的变量\r\n\t      let canMoveLeft = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该行的数字格\r\n\t        let row = this.numberCells\r\n\t          .filter((cell) => cell.y === i)\r\n\t          .sort(this.sortByX);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = 0; j < row.length; j++) {\r\n\t          //如果当前是第一个数字格，则其左边一定没有数字格，则直接推向最左边\r\n\t          if (j === 0) {\r\n\t            //如果已经在最左边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最左边则移动\r\n\t            if (row[j].x !== 0) {\r\n\t              row[j].x = 0;\r\n\t              canMoveLeft = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与上一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到上一格的后一列，条件是上一格的后一列不为当前格\r\n\t            if (row[j].num === row[j - 1].num && !visited) {\r\n\t              //移动当前数字格的坐标到上一数字格上\r\n\t              row[j].x = row[j - 1].x;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t              //获取当前数字格的DOM\r\n\t              let dom1 = document.querySelector(`#c${row[j].id}`);\r\n\t              //给当前数字格一个监听器，在动画结束后再更新合并后的数字格\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = row[j].num * 2;\r\n\t                  row[j - 1].num = newNum;\r\n\t                  row[j - 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${row[j - 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(row[j].id), 1);\r\n\t                  row.splice(j, 1);\r\n\t                  j--;\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              //若发生合并则表示当前可以向左移动，则表示这一格已进行合并，避免重复合并\r\n\t              canMoveLeft = true;\r\n\t              visited = true;\r\n\t\r\n\t              // const newNum = row[j].num * 2;\r\n\t              // row[j - 1].num = newNum;\r\n\t              // row[j - 1].color = this.color[newNum];\r\n\t              // this.numberCells.splice(this.getIndexById(row[j].id), 1);\r\n\t              // row.splice(j, 1);\r\n\t              // j--;\r\n\t              // canMoveLeft = true;\r\n\t              // visited = true;\r\n\t              // this.score += newNum;\r\n\t            } else {\r\n\t              if (row[j].x !== row[j - 1].x + 1) {\r\n\t                row[j].x = row[j - 1].x + 1;\r\n\t                canMoveLeft = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveLeft) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    moveRight() {\r\n\t      //一个表示可以向右移动的变量\r\n\t      let canMoveRight = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该行的数字格\r\n\t        let row = this.numberCells\r\n\t          .filter((cell) => cell.y === i)\r\n\t          .sort(this.sortByX);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = row.length - 1; j >= 0; j--) {\r\n\t          //如果当前是最后一个数字格，则其右边一定没有数字格，则直接推向最右边\r\n\t          if (j === row.length - 1) {\r\n\t            //如果已经在最右边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最右边则移动\r\n\t            if (row[j].x !== 3) {\r\n\t              row[j].x = 3;\r\n\t              canMoveRight = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与后一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到后一格的前一列，条件是后一格的前一列不为当前格\r\n\t            if (row[j].num === row[j + 1].num && !visited) {\r\n\t              row[j].x = row[j + 1].x;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t\r\n\t              let dom1 = document.querySelector(`#c${row[j].id}`);\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = row[j].num * 2;\r\n\t                  row[j + 1].num = newNum;\r\n\t                  row[j + 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${row[j + 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(row[j].id), 1);\r\n\t                  row.splice(j, 1);\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              canMoveRight = true;\r\n\t              visited = true;\r\n\t            } else {\r\n\t              if (row[j].x !== row[j + 1].x - 1) {\r\n\t                row[j].x = row[j + 1].x - 1;\r\n\t                canMoveRight = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveRight) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    moveUp() {\r\n\t      //一个表示可以向上移动的变量\r\n\t      let canMoveUp = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该列的数字格\r\n\t        let column = this.numberCells\r\n\t          .filter((cell) => cell.x === i)\r\n\t          .sort(this.sortByY);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = 0; j < column.length; j++) {\r\n\t          //如果当前是第一个数字格，则其上边一定没有数字格，则直接推向最上边\r\n\t          if (j === 0) {\r\n\t            //如果已经在最上边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最上边则移动\r\n\t            if (column[j].y !== 0) {\r\n\t              column[j].y = 0;\r\n\t              canMoveUp = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与上一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到上一格的后一行，条件是上一格的后一行不为当前格\r\n\t            if (column[j].num === column[j - 1].num && !visited) {\r\n\t              column[j].y = column[j - 1].y;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t\r\n\t              let dom1 = document.querySelector(`#c${column[j].id}`);\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = column[j].num * 2;\r\n\t                  column[j - 1].num = newNum;\r\n\t                  column[j - 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${column[j - 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(column[j].id), 1);\r\n\t                  column.splice(j, 1);\r\n\t                  j--;\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              canMoveUp = true;\r\n\t              visited = true;\r\n\t            } else {\r\n\t              if (column[j].y !== column[j - 1].y + 1) {\r\n\t                column[j].y = column[j - 1].y + 1;\r\n\t                canMoveUp = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveUp) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    moveDown() {\r\n\t      //一个表示可以向下移动的变量\r\n\t      let canMoveDown = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该列的数字格\r\n\t        let column = this.numberCells\r\n\t          .filter((cell) => cell.x === i)\r\n\t          .sort(this.sortByY);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = column.length - 1; j >= 0; j--) {\r\n\t          //如果当前是最后一个数字格，则其下边一定没有数字格，则直接推向最下边\r\n\t          if (j === column.length - 1) {\r\n\t            //如果已经在最后边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最后边则移动\r\n\t            if (column[j].y !== 3) {\r\n\t              column[j].y = 3;\r\n\t              canMoveDown = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与下一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到下一格的前一行，条件是下一格的前一行不为当前格\r\n\t            if (column[j].num === column[j + 1].num && !visited) {\r\n\t              column[j].y = column[j + 1].y;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t\r\n\t              let dom1 = document.querySelector(`#c${column[j].id}`);\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = column[j].num * 2;\r\n\t                  column[j + 1].num = newNum;\r\n\t                  column[j + 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${column[j + 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(column[j].id), 1);\r\n\t                  column.splice(j, 1);\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              canMoveDown = true;\r\n\t              visited = true;\r\n\t            } else {\r\n\t              if (column[j].y !== column[j + 1].y - 1) {\r\n\t                column[j].y = column[j + 1].y - 1;\r\n\t                canMoveDown = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveDown) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    isFull() {\r\n\t      return this.numberCells.length > 15;\r\n\t    },\r\n\t    isSuccess() {\r\n\t      return !!this.numberCells.find((cell) => cell.num === 8192);\r\n\t    },\r\n\t    isGameOver() {\r\n\t      //判断是否可以移动\r\n\t      //思路是看每个格子的右边或下边的格子是否与自己的数值相等\r\n\t      //因此第四行已经经过了第三行的比较，不用再向下比较\r\n\t      //第四列的已经经过第三列的比较，不用再向右比较\r\n\t      let cannotMove = () => {\r\n\t        for (let i = 0; i < 4; i++) {\r\n\t          let row = this.numberCells\r\n\t            .filter((cell) => cell.y === i)\r\n\t            .sort(this.sortByX);\r\n\t          for (let j = 0; j < 4; j++) {\r\n\t            //除第四行外，所有格子跟下一行同一列的格子比较数值是否相等\r\n\t            if (i < 3) {\r\n\t              if (row[j].num === this.getCellByPoint({ x: j, y: i + 1 }).num) {\r\n\t                return false;\r\n\t              }\r\n\t            }\r\n\t            //除第四列外，所有格子跟同一行下一列的格子比较数值是否相等\r\n\t            if (j < 3) {\r\n\t              if (row[j].num === row[j + 1].num) {\r\n\t                return false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        return true;\r\n\t      };\r\n\t      return this.isFull() && cannotMove();\r\n\t    },\r\n\t  },\r\n\t};\n</script>\n\n<style lang=\"css\">\r\n\t.home{\r\n\t\twidth: 500px;\r\n\t\tmargin: auto;\r\n\t}\r\n\t.header .button{\r\n\t\tdisplay: flex;\r\n\t\tjustify-content: space-between;\r\n\t}\r\n\t.init-button {\r\n\t  width: 110px;\r\n\t  padding: 10px;\r\n\t  background-color: #8f7a66;\r\n\t  color: #fff;\r\n\t  border: none;\r\n\t  border-radius: 8px;\r\n\t  cursor: pointer;\r\n\t  outline: none;\r\n\t  font-size: 16px;\r\n\t  font-weight: bold;\r\n\t  &:hover {\r\n\t    background-color: #9f8a77;\r\n\t  }\r\n\t  }\r\n\t.container{\r\n\t\t width: 500px;\r\n\t\t height: 500px;\r\n\t\t margin-top: 20px;\r\n\t\t position: relative;\r\n\t}\r\n\t.container .mask{\r\n\t\t position: absolute;\r\n\t\t top: 0;\r\n\t\t right: 0;\r\n\t\t bottom: 0;\r\n\t\t left: 0;\r\n\t\t z-index: 9999;\r\n\t\t background: rgba(238, 228, 218, 0.5);\r\n\t\t text-align: center;\r\n\t}\r\n\t.container .mask h1{\r\n\t\tfont-size: 60px;\r\n\t\tfont-weight: 700;\r\n\t\theight: 60px;\r\n\t\tline-height: 60px;\r\n\t\tmargin-top: 120px;\r\n\t\tcolor: #776e65;\r\n\t}\r\n\t.container .mask button{\r\n\t\t  margin-top: 30px;\r\n\t}\r\n\t.number-cells .number-cell{\r\n\t\ttransition: 100ms top, 100ms left;\r\n\t}\r\n\t.appear-enter-active {\r\n\t  transition: 100ms top, 100ms left;\r\n\t}\r\n\t.appear-leave-active {\r\n\t\ttransition: 100ms top, 100ms left;\r\n\t}\r\n\t@keyframes appear {\r\n\t  0% {\r\n\t    opacity: 0;\r\n\t    transform: scale(0);\r\n\t  }\r\n\t  50% {\r\n\t    opacity: 0;\r\n\t    transform: scale(0.5);\r\n\t  }\r\n\t  100% {\r\n\t    opacity: 1;\r\n\t    transform: scale(1);\r\n\t  }\r\n\t }\n</style>\n"],"sourceRoot":"src/components"}]}