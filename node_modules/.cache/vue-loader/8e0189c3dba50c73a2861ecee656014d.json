{"remainingRequest":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\src\\components\\content.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\src\\components\\content.vue","mtime":1620753042660},{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\css-loader\\index.js","mtime":1620651791057},{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":1620651837925},{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\postcss-loader\\src\\index.js","mtime":1620651841433},{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620651810122},{"path":"E:\\练习\\导师项目\\分别基于Jquery和vue.cli系统的2048小游戏\\2048（vue）\\node_modules\\vue-loader\\lib\\index.js","mtime":1620651837901}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.home{\n\twidth: 500px;\n\tmargin: auto;\n}\n.header .button{\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n.init-button {\n  width: 110px;\n  padding: 10px;\n  background-color: #8f7a66;\n  color: #fff;\n  border: none;\n  border-radius: 8px;\n  cursor: pointer;\n  outline: none;\n  font-size: 16px;\n  font-weight: bold;\n  &:hover {\n    background-color: #9f8a77;\n  }\n  }\n.container{\n\t width: 500px;\n\t height: 500px;\n\t margin-top: 20px;\n\t position: relative;\n}\n.container .mask{\n\t position: absolute;\n\t top: 0;\n\t right: 0;\n\t bottom: 0;\n\t left: 0;\n\t z-index: 9999;\n\t background: rgba(238, 228, 218, 0.5);\n\t text-align: center;\n}\n.container .mask h1{\n\tfont-size: 60px;\n\tfont-weight: 700;\n\theight: 60px;\n\tline-height: 60px;\n\tmargin-top: 120px;\n\tcolor: #776e65;\n}\n.container .mask button{\n\t  margin-top: 30px;\n}\n.number-cells .number-cell{\n\ttransition: 100ms top, 100ms left;\n}\n.appear-enter-active {\n  transition: 100ms top, 100ms left;\n}\n.appear-leave-active {\n\ttransition: 100ms top, 100ms left;\n}\n@keyframes appear {\n  0% {\n    opacity: 0;\n    transform: scale(0);\n  }\n  50% {\n    opacity: 0;\n    transform: scale(0.5);\n  }\n  100% {\n    opacity: 1;\n    transform: scale(1);\n  }\n }\n",{"version":3,"sources":["content.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"content.vue","sourceRoot":"src/components","sourcesContent":["<template>\r\n\t<div class=\"home\">\r\n\t\t<div class=\"header\">\r\n\t\t\t<h1>2048</h1>\r\n\t\t\t<div class=\"button\">\r\n\t\t\t\t<button class=\"init-button\">\r\n\t\t\t\t  Score: <span>{{ score }}</span>\r\n\t\t\t\t</button>\r\n\t\t\t\t<button @click=\"init\" class=\"init-button\">New Game</button>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t<div class=\"container\">\r\n\t\t\t<div class=\"mask\" v-if=\"success\">\r\n\t\t\t\t<h1>You win!</h1>\r\n\t\t\t\t<button @click=\"init\" class=\"init-button\">Try again</button>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"mask\" v-if=\"gameover\">\r\n\t\t\t\t<h1>Game over!</h1>\r\n\t\t\t\t<button @click=\"init\" class=\"init-button\">Try again</button>\r\n\t\t\t</div>\r\n\t\t\t<Background></Background>\r\n\t\t\t<div class=\"number-cells\">\r\n\t\t\t\t<transition-group name=\"appear\">\r\n\t\t\t\t<div\r\n\t\t\t\t\tclass=\"number-cell\"\r\n\t\t\t\t\tv-for=\"cell of numberCells\"\r\n\t\t\t\t\t:id=\"`c${cell.id}`\"\r\n\t\t\t\t\t:key=\"cell.id\"\r\n\t\t\t\t\t:style=\"\r\n\t\t\t\t\t  `\r\n\t\t\t\t  width: 100px;\r\n\t\t\t\t  height: 100px;\r\n\t\t\t\t  border-radius: 5px;\r\n\t\t\t\t  font-size: 32px;\r\n\t\t\t\t  font-weight: bold;\r\n\t\t\t\t  line-height: 80px;\r\n\t\t\t\t  color: #776e65;\r\n\t\t\t\r\n\t\t\t\t  position: absolute;\r\n\t\t\t\t  z-index: ${cell.num};\r\n\t\t\t\t  backgroundColor: ${cell.color};\r\n\t\t\t\t  top: ${getTop(cell)};\r\n\t\t\t\t  left: ${getLeft(cell)};\r\n\t\t\t\t  `\r\n\t\t\t\t\t\"\r\n\t\t\t\t  > {{ cell.num }}\r\n\t\t\t\t  </div>\r\n\t\t\t\t</transition-group>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\n</template>\n\n<script>\r\n\timport Background from '../components/background.vue'\r\n\texport default {\r\n\t  name: 'Home',\r\n\t  components: {\r\n\t    Background,\r\n\t  },\r\n\t  data() {\r\n\t    return {\r\n\t      score: 0,\r\n\t      numberCells: [],\r\n\t      color: {\r\n\t        2: '#eee4da',\r\n\t        4: '#ede0c8',\r\n\t        8: '#f2b179',\r\n\t        16: '#f59563',\r\n\t        32: '#f67c5f',\r\n\t        64: '#f65e3b',\r\n\t        128: '#edcf72',\r\n\t        256: '#edcc61',\r\n\t        512: '#0444BF',\r\n\t        1024: '#A79674',\r\n\t        2048: '#282726',\r\n\t        4096: '#280b21',\r\n\t        8192: '#281d04',\r\n\t      },\r\n\t      auxId: 0,\r\n\t      success: false,\r\n\t      gameover: false,\r\n\t      canMove: true,\r\n\t    };\r\n\t  },\r\n\t  mounted() {\r\n\t    this.init();\r\n\t    document.addEventListener('keyup', (event) => {\r\n\t      if (!this.canMove) {\r\n\t        return;\r\n\t      }\r\n\t      switch (event.keyCode) {\r\n\t        case 38:\r\n\t          this.moveUp();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t        case 40:\r\n\t          this.moveDown();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t        case 37:\r\n\t          this.moveLeft();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t        case 39:\r\n\t          this.moveRight();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t      }\r\n\t    });\r\n\t  },\r\n\t  methods: {\r\n\t\t  //初始化游戏\r\n\t    init() {\r\n\t      this.numberCells.length = 0;\r\n\t      this.score = 0;\r\n\t      this.auxId = 0;\r\n\t      this.success = false;\r\n\t      this.gameover = false;\r\n\t      this.generateOneNumberCell();\r\n\t      this.generateOneNumberCell();\r\n\t    },\r\n\t\t\r\n\t\t\r\n\t\t/* 先随机生成一个2或4的数字，然后随机获得0-3的坐标值，\r\n\t\t再去判断当前生成的坐标上有没有其他格子，若有则继续随机\r\n\t\t生成直至找到一个空位，然后再push到数组中 */\r\n\t    generateOneNumberCell() {\r\n\t      if (this.isFull()) {\r\n\t        return;\r\n\t      }\r\n\t      const num = this.random24();\r\n\t      const newCell = {//创建一个上层单元格对象\r\n\t        x: this.random0123(),\r\n\t        y: this.random0123(),\r\n\t        num: num,\r\n\t        color: this.color[num],\r\n\t        id: this.auxId++,\r\n\t      };\r\n\t      let isExist = () => this.getCellByPoint({ x: newCell.x, y: newCell.y });\r\n\t      while (isExist()) {\r\n\t        newCell.x = this.random0123();\r\n\t        newCell.y = this.random0123();\r\n\t      }\r\n\t      this.numberCells.push(newCell);\r\n\t    },\r\n\t\t//随机产生2或4\r\n\t    random24() {\r\n\t      //70%概率是2\r\n\t      return Math.random() <= 0.7 ? 2 : 4;\r\n\t    },\r\n\t    random0123() {\r\n\t      return parseInt(Math.random() * 4);\r\n\t    },\r\n\t    getCellByPoint({ x, y }) {\r\n\t      return this.numberCells.find((cell) => cell.x === x && cell.y === y);\r\n\t    },\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t    getTop(cell) {\r\n\t      return `${20 + cell.y * 120}px`;\r\n\t    },\r\n\t    getLeft(cell) {\r\n\t      return `${20 + cell.x * 120}px`;\r\n\t    },\r\n\t    sortByX(a, b) {\r\n\t      return a.x - b.x;\r\n\t    },\r\n\t    sortByY(a, b) {\r\n\t      return a.y - b.y;\r\n\t    },\r\n\t    getIndexById(id) {\r\n\t      return this.numberCells.findIndex((cell) => cell.id === id);\r\n\t    },\r\n\t\t//单元格合并动画\r\n\t    animateMerge(dom) {\r\n\t      dom.animate(\r\n\t            [\r\n\t              { transform: 'scale(0)' },\r\n\t              { transform: 'scale(1.2)' },\r\n\t              { transform: 'scale(1)' },\r\n\t            ],\r\n\t            {\r\n\t              duration: 150,\r\n\t            }\r\n\t      );\r\n\t      //合并后可以接受键盘输入\r\n\t      this.canMove = true;\r\n\t    },\r\n\t    moveLeft() {\r\n\t      //一个表示可以向左移动的变量\r\n\t      let canMoveLeft = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该行的数字格\r\n\t        let row = this.numberCells\r\n\t          .filter((cell) => cell.y === i)\r\n\t          .sort(this.sortByX);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = 0; j < row.length; j++) {\r\n\t          //如果当前是第一个数字格，则其左边一定没有数字格，则直接推向最左边\r\n\t          if (j === 0) {\r\n\t            //如果已经在最左边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最左边则移动\r\n\t            if (row[j].x !== 0) {\r\n\t              row[j].x = 0;\r\n\t              canMoveLeft = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与上一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到上一格的后一列，条件是上一格的后一列不为当前格\r\n\t            if (row[j].num === row[j - 1].num && !visited) {\r\n\t              //移动当前数字格的坐标到上一数字格上\r\n\t              row[j].x = row[j - 1].x;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t              //获取当前数字格的DOM\r\n\t              let dom1 = document.querySelector(`#c${row[j].id}`);\r\n\t              //给当前数字格一个监听器，在动画结束后再更新合并后的数字格\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = row[j].num * 2;\r\n\t                  row[j - 1].num = newNum;\r\n\t                  row[j - 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${row[j - 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(row[j].id), 1);\r\n\t                  row.splice(j, 1);\r\n\t                  j--;\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              //若发生合并则表示当前可以向左移动，则表示这一格已进行合并，避免重复合并\r\n\t              canMoveLeft = true;\r\n\t              visited = true;\r\n\t\r\n\t              // const newNum = row[j].num * 2;\r\n\t              // row[j - 1].num = newNum;\r\n\t              // row[j - 1].color = this.color[newNum];\r\n\t              // this.numberCells.splice(this.getIndexById(row[j].id), 1);\r\n\t              // row.splice(j, 1);\r\n\t              // j--;\r\n\t              // canMoveLeft = true;\r\n\t              // visited = true;\r\n\t              // this.score += newNum;\r\n\t            } else {\r\n\t              if (row[j].x !== row[j - 1].x + 1) {\r\n\t                row[j].x = row[j - 1].x + 1;\r\n\t                canMoveLeft = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveLeft) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    moveRight() {\r\n\t      //一个表示可以向右移动的变量\r\n\t      let canMoveRight = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该行的数字格\r\n\t        let row = this.numberCells\r\n\t          .filter((cell) => cell.y === i)\r\n\t          .sort(this.sortByX);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = row.length - 1; j >= 0; j--) {\r\n\t          //如果当前是最后一个数字格，则其右边一定没有数字格，则直接推向最右边\r\n\t          if (j === row.length - 1) {\r\n\t            //如果已经在最右边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最右边则移动\r\n\t            if (row[j].x !== 3) {\r\n\t              row[j].x = 3;\r\n\t              canMoveRight = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与后一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到后一格的前一列，条件是后一格的前一列不为当前格\r\n\t            if (row[j].num === row[j + 1].num && !visited) {\r\n\t              row[j].x = row[j + 1].x;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t\r\n\t              let dom1 = document.querySelector(`#c${row[j].id}`);\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = row[j].num * 2;\r\n\t                  row[j + 1].num = newNum;\r\n\t                  row[j + 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${row[j + 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(row[j].id), 1);\r\n\t                  row.splice(j, 1);\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              canMoveRight = true;\r\n\t              visited = true;\r\n\t            } else {\r\n\t              if (row[j].x !== row[j + 1].x - 1) {\r\n\t                row[j].x = row[j + 1].x - 1;\r\n\t                canMoveRight = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveRight) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    moveUp() {\r\n\t      //一个表示可以向上移动的变量\r\n\t      let canMoveUp = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该列的数字格\r\n\t        let column = this.numberCells\r\n\t          .filter((cell) => cell.x === i)\r\n\t          .sort(this.sortByY);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = 0; j < column.length; j++) {\r\n\t          //如果当前是第一个数字格，则其上边一定没有数字格，则直接推向最上边\r\n\t          if (j === 0) {\r\n\t            //如果已经在最上边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最上边则移动\r\n\t            if (column[j].y !== 0) {\r\n\t              column[j].y = 0;\r\n\t              canMoveUp = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与上一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到上一格的后一行，条件是上一格的后一行不为当前格\r\n\t            if (column[j].num === column[j - 1].num && !visited) {\r\n\t              column[j].y = column[j - 1].y;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t\r\n\t              let dom1 = document.querySelector(`#c${column[j].id}`);\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = column[j].num * 2;\r\n\t                  column[j - 1].num = newNum;\r\n\t                  column[j - 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${column[j - 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(column[j].id), 1);\r\n\t                  column.splice(j, 1);\r\n\t                  j--;\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              canMoveUp = true;\r\n\t              visited = true;\r\n\t            } else {\r\n\t              if (column[j].y !== column[j - 1].y + 1) {\r\n\t                column[j].y = column[j - 1].y + 1;\r\n\t                canMoveUp = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveUp) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    moveDown() {\r\n\t      //一个表示可以向下移动的变量\r\n\t      let canMoveDown = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该列的数字格\r\n\t        let column = this.numberCells\r\n\t          .filter((cell) => cell.x === i)\r\n\t          .sort(this.sortByY);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = column.length - 1; j >= 0; j--) {\r\n\t          //如果当前是最后一个数字格，则其下边一定没有数字格，则直接推向最下边\r\n\t          if (j === column.length - 1) {\r\n\t            //如果已经在最后边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最后边则移动\r\n\t            if (column[j].y !== 3) {\r\n\t              column[j].y = 3;\r\n\t              canMoveDown = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与下一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到下一格的前一行，条件是下一格的前一行不为当前格\r\n\t            if (column[j].num === column[j + 1].num && !visited) {\r\n\t              column[j].y = column[j + 1].y;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t\r\n\t              let dom1 = document.querySelector(`#c${column[j].id}`);\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = column[j].num * 2;\r\n\t                  column[j + 1].num = newNum;\r\n\t                  column[j + 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${column[j + 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(column[j].id), 1);\r\n\t                  column.splice(j, 1);\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              canMoveDown = true;\r\n\t              visited = true;\r\n\t            } else {\r\n\t              if (column[j].y !== column[j + 1].y - 1) {\r\n\t                column[j].y = column[j + 1].y - 1;\r\n\t                canMoveDown = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveDown) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    isFull() {\r\n\t      return this.numberCells.length > 15;\r\n\t    },\r\n\t    isSuccess() {\r\n\t      return !!this.numberCells.find((cell) => cell.num === 8192);\r\n\t    },\r\n\t    isGameOver() {\r\n\t      //判断是否可以移动\r\n\t      //思路是看每个格子的右边或下边的格子是否与自己的数值相等\r\n\t      //因此第四行已经经过了第三行的比较，不用再向下比较\r\n\t      //第四列的已经经过第三列的比较，不用再向右比较\r\n\t      let cannotMove = () => {\r\n\t        for (let i = 0; i < 4; i++) {\r\n\t          let row = this.numberCells\r\n\t            .filter((cell) => cell.y === i)\r\n\t            .sort(this.sortByX);\r\n\t          for (let j = 0; j < 4; j++) {\r\n\t            //除第四行外，所有格子跟下一行同一列的格子比较数值是否相等\r\n\t            if (i < 3) {\r\n\t              if (row[j].num === this.getCellByPoint({ x: j, y: i + 1 }).num) {\r\n\t                return false;\r\n\t              }\r\n\t            }\r\n\t            //除第四列外，所有格子跟同一行下一列的格子比较数值是否相等\r\n\t            if (j < 3) {\r\n\t              if (row[j].num === row[j + 1].num) {\r\n\t                return false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        return true;\r\n\t      };\r\n\t      return this.isFull() && cannotMove();\r\n\t    },\r\n\t  },\r\n\t};\n</script>\n\n<style lang=\"css\">\r\n\t.home{\r\n\t\twidth: 500px;\r\n\t\tmargin: auto;\r\n\t}\r\n\t.header .button{\r\n\t\tdisplay: flex;\r\n\t\tjustify-content: space-between;\r\n\t}\r\n\t.init-button {\r\n\t  width: 110px;\r\n\t  padding: 10px;\r\n\t  background-color: #8f7a66;\r\n\t  color: #fff;\r\n\t  border: none;\r\n\t  border-radius: 8px;\r\n\t  cursor: pointer;\r\n\t  outline: none;\r\n\t  font-size: 16px;\r\n\t  font-weight: bold;\r\n\t  &:hover {\r\n\t    background-color: #9f8a77;\r\n\t  }\r\n\t  }\r\n\t.container{\r\n\t\t width: 500px;\r\n\t\t height: 500px;\r\n\t\t margin-top: 20px;\r\n\t\t position: relative;\r\n\t}\r\n\t.container .mask{\r\n\t\t position: absolute;\r\n\t\t top: 0;\r\n\t\t right: 0;\r\n\t\t bottom: 0;\r\n\t\t left: 0;\r\n\t\t z-index: 9999;\r\n\t\t background: rgba(238, 228, 218, 0.5);\r\n\t\t text-align: center;\r\n\t}\r\n\t.container .mask h1{\r\n\t\tfont-size: 60px;\r\n\t\tfont-weight: 700;\r\n\t\theight: 60px;\r\n\t\tline-height: 60px;\r\n\t\tmargin-top: 120px;\r\n\t\tcolor: #776e65;\r\n\t}\r\n\t.container .mask button{\r\n\t\t  margin-top: 30px;\r\n\t}\r\n\t.number-cells .number-cell{\r\n\t\ttransition: 100ms top, 100ms left;\r\n\t}\r\n\t.appear-enter-active {\r\n\t  transition: 100ms top, 100ms left;\r\n\t}\r\n\t.appear-leave-active {\r\n\t\ttransition: 100ms top, 100ms left;\r\n\t}\r\n\t@keyframes appear {\r\n\t  0% {\r\n\t    opacity: 0;\r\n\t    transform: scale(0);\r\n\t  }\r\n\t  50% {\r\n\t    opacity: 0;\r\n\t    transform: scale(0.5);\r\n\t  }\r\n\t  100% {\r\n\t    opacity: 1;\r\n\t    transform: scale(1);\r\n\t  }\r\n\t }\n</style>\n"]}]}