{"remainingRequest":"E:\\练习\\导师项目\\2048.1\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\练习\\导师项目\\2048.1\\src\\components\\content.vue?vue&type=script&lang=js&","dependencies":[{"path":"E:\\练习\\导师项目\\2048.1\\src\\components\\content.vue","mtime":1620753042660},{"path":"E:\\练习\\导师项目\\2048.1\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620651810122},{"path":"E:\\练习\\导师项目\\2048.1\\node_modules\\babel-loader\\lib\\index.js","mtime":1620651842149},{"path":"E:\\练习\\导师项目\\2048.1\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620651810122},{"path":"E:\\练习\\导师项目\\2048.1\\node_modules\\vue-loader\\lib\\index.js","mtime":1620651837901}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport Background from '../components/background.vue'\nexport default {\n  name: 'Home',\n  components: {\n    Background,\n  },\n  data() {\n    return {\n      score: 0,\n      numberCells: [],\n      color: {\n        2: '#eee4da',\n        4: '#ede0c8',\n        8: '#f2b179',\n        16: '#f59563',\n        32: '#f67c5f',\n        64: '#f65e3b',\n        128: '#edcf72',\n        256: '#edcc61',\n        512: '#0444BF',\n        1024: '#A79674',\n        2048: '#282726',\n        4096: '#280b21',\n        8192: '#281d04',\n      },\n      auxId: 0,\n      success: false,\n      gameover: false,\n      canMove: true,\n    };\n  },\n  mounted() {\n    this.init();\n    document.addEventListener('keyup', (event) => {\n      if (!this.canMove) {\n        return;\n      }\n      switch (event.keyCode) {\n        case 38:\n          this.moveUp();\n          this.success = this.isSuccess();\n          this.gameover = this.isGameOver();\n          break;\n        case 40:\n          this.moveDown();\n          this.success = this.isSuccess();\n          this.gameover = this.isGameOver();\n          break;\n        case 37:\n          this.moveLeft();\n          this.success = this.isSuccess();\n          this.gameover = this.isGameOver();\n          break;\n        case 39:\n          this.moveRight();\n          this.success = this.isSuccess();\n          this.gameover = this.isGameOver();\n          break;\n      }\n    });\n  },\n  methods: {\n\t  //初始化游戏\n    init() {\n      this.numberCells.length = 0;\n      this.score = 0;\n      this.auxId = 0;\n      this.success = false;\n      this.gameover = false;\n      this.generateOneNumberCell();\n      this.generateOneNumberCell();\n    },\n\t\n\t\n\t/* 先随机生成一个2或4的数字，然后随机获得0-3的坐标值，\n\t再去判断当前生成的坐标上有没有其他格子，若有则继续随机\n\t生成直至找到一个空位，然后再push到数组中 */\n    generateOneNumberCell() {\n      if (this.isFull()) {\n        return;\n      }\n      const num = this.random24();\n      const newCell = {//创建一个上层单元格对象\n        x: this.random0123(),\n        y: this.random0123(),\n        num: num,\n        color: this.color[num],\n        id: this.auxId++,\n      };\n      let isExist = () => this.getCellByPoint({ x: newCell.x, y: newCell.y });\n      while (isExist()) {\n        newCell.x = this.random0123();\n        newCell.y = this.random0123();\n      }\n      this.numberCells.push(newCell);\n    },\n\t//随机产生2或4\n    random24() {\n      //70%概率是2\n      return Math.random() <= 0.7 ? 2 : 4;\n    },\n    random0123() {\n      return parseInt(Math.random() * 4);\n    },\n    getCellByPoint({ x, y }) {\n      return this.numberCells.find((cell) => cell.x === x && cell.y === y);\n    },\n\t\n\t\n\t\n    getTop(cell) {\n      return `${20 + cell.y * 120}px`;\n    },\n    getLeft(cell) {\n      return `${20 + cell.x * 120}px`;\n    },\n    sortByX(a, b) {\n      return a.x - b.x;\n    },\n    sortByY(a, b) {\n      return a.y - b.y;\n    },\n    getIndexById(id) {\n      return this.numberCells.findIndex((cell) => cell.id === id);\n    },\n\t//单元格合并动画\n    animateMerge(dom) {\n      dom.animate(\n            [\n              { transform: 'scale(0)' },\n              { transform: 'scale(1.2)' },\n              { transform: 'scale(1)' },\n            ],\n            {\n              duration: 150,\n            }\n      );\n      //合并后可以接受键盘输入\n      this.canMove = true;\n    },\n    moveLeft() {\n      //一个表示可以向左移动的变量\n      let canMoveLeft = false;\n      for (let i = 0; i < 4; i++) {\n        //按顺序获得该行的数字格\n        let row = this.numberCells\n          .filter((cell) => cell.y === i)\n          .sort(this.sortByX);\n        //一个表示上一格已经过合并的变量\n        let visited = false;\n        for (let j = 0; j < row.length; j++) {\n          //如果当前是第一个数字格，则其左边一定没有数字格，则直接推向最左边\n          if (j === 0) {\n            //如果已经在最左边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最左边则移动\n            if (row[j].x !== 0) {\n              row[j].x = 0;\n              canMoveLeft = true;\n            }\n          } else {\n            //如果当前数字格与上一数字格的数字一样，则合并\n            //否则就是将其挪到上一格的后一列，条件是上一格的后一列不为当前格\n            if (row[j].num === row[j - 1].num && !visited) {\n              //移动当前数字格的坐标到上一数字格上\n              row[j].x = row[j - 1].x;\n              //滑动中禁止键盘输入\n              this.canMove = false;\n              //获取当前数字格的DOM\n              let dom1 = document.querySelector(`#c${row[j].id}`);\n              //给当前数字格一个监听器，在动画结束后再更新合并后的数字格\n              dom1.addEventListener(\n                'transitionend',\n                () => {\n                  const newNum = row[j].num * 2;\n                  row[j - 1].num = newNum;\n                  row[j - 1].color = this.color[newNum];\n                  let dom2 = document.querySelector(`#c${row[j - 1].id}`);\n                  this.animateMerge(dom2);\n                  this.numberCells.splice(this.getIndexById(row[j].id), 1);\n                  row.splice(j, 1);\n                  j--;\n                  this.score += newNum;\n                },\n                true\n              );\n              //若发生合并则表示当前可以向左移动，则表示这一格已进行合并，避免重复合并\n              canMoveLeft = true;\n              visited = true;\n\n              // const newNum = row[j].num * 2;\n              // row[j - 1].num = newNum;\n              // row[j - 1].color = this.color[newNum];\n              // this.numberCells.splice(this.getIndexById(row[j].id), 1);\n              // row.splice(j, 1);\n              // j--;\n              // canMoveLeft = true;\n              // visited = true;\n              // this.score += newNum;\n            } else {\n              if (row[j].x !== row[j - 1].x + 1) {\n                row[j].x = row[j - 1].x + 1;\n                canMoveLeft = true;\n                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n                visited = false;\n              }\n            }\n          }\n        }\n      }\n      if (canMoveLeft) {\n        this.generateOneNumberCell();\n      }\n    },\n    moveRight() {\n      //一个表示可以向右移动的变量\n      let canMoveRight = false;\n      for (let i = 0; i < 4; i++) {\n        //按顺序获得该行的数字格\n        let row = this.numberCells\n          .filter((cell) => cell.y === i)\n          .sort(this.sortByX);\n        //一个表示上一格已经过合并的变量\n        let visited = false;\n        for (let j = row.length - 1; j >= 0; j--) {\n          //如果当前是最后一个数字格，则其右边一定没有数字格，则直接推向最右边\n          if (j === row.length - 1) {\n            //如果已经在最右边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最右边则移动\n            if (row[j].x !== 3) {\n              row[j].x = 3;\n              canMoveRight = true;\n            }\n          } else {\n            //如果当前数字格与后一数字格的数字一样，则合并\n            //否则就是将其挪到后一格的前一列，条件是后一格的前一列不为当前格\n            if (row[j].num === row[j + 1].num && !visited) {\n              row[j].x = row[j + 1].x;\n              //滑动中禁止键盘输入\n              this.canMove = false;\n\n              let dom1 = document.querySelector(`#c${row[j].id}`);\n              dom1.addEventListener(\n                'transitionend',\n                () => {\n                  const newNum = row[j].num * 2;\n                  row[j + 1].num = newNum;\n                  row[j + 1].color = this.color[newNum];\n                  let dom2 = document.querySelector(`#c${row[j + 1].id}`);\n                  this.animateMerge(dom2);\n                  this.numberCells.splice(this.getIndexById(row[j].id), 1);\n                  row.splice(j, 1);\n                  this.score += newNum;\n                },\n                true\n              );\n              canMoveRight = true;\n              visited = true;\n            } else {\n              if (row[j].x !== row[j + 1].x - 1) {\n                row[j].x = row[j + 1].x - 1;\n                canMoveRight = true;\n                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n                visited = false;\n              }\n            }\n          }\n        }\n      }\n      if (canMoveRight) {\n        this.generateOneNumberCell();\n      }\n    },\n    moveUp() {\n      //一个表示可以向上移动的变量\n      let canMoveUp = false;\n      for (let i = 0; i < 4; i++) {\n        //按顺序获得该列的数字格\n        let column = this.numberCells\n          .filter((cell) => cell.x === i)\n          .sort(this.sortByY);\n        //一个表示上一格已经过合并的变量\n        let visited = false;\n        for (let j = 0; j < column.length; j++) {\n          //如果当前是第一个数字格，则其上边一定没有数字格，则直接推向最上边\n          if (j === 0) {\n            //如果已经在最上边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最上边则移动\n            if (column[j].y !== 0) {\n              column[j].y = 0;\n              canMoveUp = true;\n            }\n          } else {\n            //如果当前数字格与上一数字格的数字一样，则合并\n            //否则就是将其挪到上一格的后一行，条件是上一格的后一行不为当前格\n            if (column[j].num === column[j - 1].num && !visited) {\n              column[j].y = column[j - 1].y;\n              //滑动中禁止键盘输入\n              this.canMove = false;\n\n              let dom1 = document.querySelector(`#c${column[j].id}`);\n              dom1.addEventListener(\n                'transitionend',\n                () => {\n                  const newNum = column[j].num * 2;\n                  column[j - 1].num = newNum;\n                  column[j - 1].color = this.color[newNum];\n                  let dom2 = document.querySelector(`#c${column[j - 1].id}`);\n                  this.animateMerge(dom2);\n                  this.numberCells.splice(this.getIndexById(column[j].id), 1);\n                  column.splice(j, 1);\n                  j--;\n                  this.score += newNum;\n                },\n                true\n              );\n              canMoveUp = true;\n              visited = true;\n            } else {\n              if (column[j].y !== column[j - 1].y + 1) {\n                column[j].y = column[j - 1].y + 1;\n                canMoveUp = true;\n                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n                visited = false;\n              }\n            }\n          }\n        }\n      }\n      if (canMoveUp) {\n        this.generateOneNumberCell();\n      }\n    },\n    moveDown() {\n      //一个表示可以向下移动的变量\n      let canMoveDown = false;\n      for (let i = 0; i < 4; i++) {\n        //按顺序获得该列的数字格\n        let column = this.numberCells\n          .filter((cell) => cell.x === i)\n          .sort(this.sortByY);\n        //一个表示上一格已经过合并的变量\n        let visited = false;\n        for (let j = column.length - 1; j >= 0; j--) {\n          //如果当前是最后一个数字格，则其下边一定没有数字格，则直接推向最下边\n          if (j === column.length - 1) {\n            //如果已经在最后边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最后边则移动\n            if (column[j].y !== 3) {\n              column[j].y = 3;\n              canMoveDown = true;\n            }\n          } else {\n            //如果当前数字格与下一数字格的数字一样，则合并\n            //否则就是将其挪到下一格的前一行，条件是下一格的前一行不为当前格\n            if (column[j].num === column[j + 1].num && !visited) {\n              column[j].y = column[j + 1].y;\n              //滑动中禁止键盘输入\n              this.canMove = false;\n\n              let dom1 = document.querySelector(`#c${column[j].id}`);\n              dom1.addEventListener(\n                'transitionend',\n                () => {\n                  const newNum = column[j].num * 2;\n                  column[j + 1].num = newNum;\n                  column[j + 1].color = this.color[newNum];\n                  let dom2 = document.querySelector(`#c${column[j + 1].id}`);\n                  this.animateMerge(dom2);\n                  this.numberCells.splice(this.getIndexById(column[j].id), 1);\n                  column.splice(j, 1);\n                  this.score += newNum;\n                },\n                true\n              );\n              canMoveDown = true;\n              visited = true;\n            } else {\n              if (column[j].y !== column[j + 1].y - 1) {\n                column[j].y = column[j + 1].y - 1;\n                canMoveDown = true;\n                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n                visited = false;\n              }\n            }\n          }\n        }\n      }\n      if (canMoveDown) {\n        this.generateOneNumberCell();\n      }\n    },\n    isFull() {\n      return this.numberCells.length > 15;\n    },\n    isSuccess() {\n      return !!this.numberCells.find((cell) => cell.num === 8192);\n    },\n    isGameOver() {\n      //判断是否可以移动\n      //思路是看每个格子的右边或下边的格子是否与自己的数值相等\n      //因此第四行已经经过了第三行的比较，不用再向下比较\n      //第四列的已经经过第三列的比较，不用再向右比较\n      let cannotMove = () => {\n        for (let i = 0; i < 4; i++) {\n          let row = this.numberCells\n            .filter((cell) => cell.y === i)\n            .sort(this.sortByX);\n          for (let j = 0; j < 4; j++) {\n            //除第四行外，所有格子跟下一行同一列的格子比较数值是否相等\n            if (i < 3) {\n              if (row[j].num === this.getCellByPoint({ x: j, y: i + 1 }).num) {\n                return false;\n              }\n            }\n            //除第四列外，所有格子跟同一行下一列的格子比较数值是否相等\n            if (j < 3) {\n              if (row[j].num === row[j + 1].num) {\n                return false;\n              }\n            }\n          }\n        }\n        return true;\n      };\n      return this.isFull() && cannotMove();\n    },\n  },\n};\n",{"version":3,"sources":["content.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"content.vue","sourceRoot":"src/components","sourcesContent":["<template>\r\n\t<div class=\"home\">\r\n\t\t<div class=\"header\">\r\n\t\t\t<h1>2048</h1>\r\n\t\t\t<div class=\"button\">\r\n\t\t\t\t<button class=\"init-button\">\r\n\t\t\t\t  Score: <span>{{ score }}</span>\r\n\t\t\t\t</button>\r\n\t\t\t\t<button @click=\"init\" class=\"init-button\">New Game</button>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t<div class=\"container\">\r\n\t\t\t<div class=\"mask\" v-if=\"success\">\r\n\t\t\t\t<h1>You win!</h1>\r\n\t\t\t\t<button @click=\"init\" class=\"init-button\">Try again</button>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"mask\" v-if=\"gameover\">\r\n\t\t\t\t<h1>Game over!</h1>\r\n\t\t\t\t<button @click=\"init\" class=\"init-button\">Try again</button>\r\n\t\t\t</div>\r\n\t\t\t<Background></Background>\r\n\t\t\t<div class=\"number-cells\">\r\n\t\t\t\t<transition-group name=\"appear\">\r\n\t\t\t\t<div\r\n\t\t\t\t\tclass=\"number-cell\"\r\n\t\t\t\t\tv-for=\"cell of numberCells\"\r\n\t\t\t\t\t:id=\"`c${cell.id}`\"\r\n\t\t\t\t\t:key=\"cell.id\"\r\n\t\t\t\t\t:style=\"\r\n\t\t\t\t\t  `\r\n\t\t\t\t  width: 100px;\r\n\t\t\t\t  height: 100px;\r\n\t\t\t\t  border-radius: 5px;\r\n\t\t\t\t  font-size: 32px;\r\n\t\t\t\t  font-weight: bold;\r\n\t\t\t\t  line-height: 80px;\r\n\t\t\t\t  color: #776e65;\r\n\t\t\t\r\n\t\t\t\t  position: absolute;\r\n\t\t\t\t  z-index: ${cell.num};\r\n\t\t\t\t  backgroundColor: ${cell.color};\r\n\t\t\t\t  top: ${getTop(cell)};\r\n\t\t\t\t  left: ${getLeft(cell)};\r\n\t\t\t\t  `\r\n\t\t\t\t\t\"\r\n\t\t\t\t  > {{ cell.num }}\r\n\t\t\t\t  </div>\r\n\t\t\t\t</transition-group>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\n</template>\n\n<script>\r\n\timport Background from '../components/background.vue'\r\n\texport default {\r\n\t  name: 'Home',\r\n\t  components: {\r\n\t    Background,\r\n\t  },\r\n\t  data() {\r\n\t    return {\r\n\t      score: 0,\r\n\t      numberCells: [],\r\n\t      color: {\r\n\t        2: '#eee4da',\r\n\t        4: '#ede0c8',\r\n\t        8: '#f2b179',\r\n\t        16: '#f59563',\r\n\t        32: '#f67c5f',\r\n\t        64: '#f65e3b',\r\n\t        128: '#edcf72',\r\n\t        256: '#edcc61',\r\n\t        512: '#0444BF',\r\n\t        1024: '#A79674',\r\n\t        2048: '#282726',\r\n\t        4096: '#280b21',\r\n\t        8192: '#281d04',\r\n\t      },\r\n\t      auxId: 0,\r\n\t      success: false,\r\n\t      gameover: false,\r\n\t      canMove: true,\r\n\t    };\r\n\t  },\r\n\t  mounted() {\r\n\t    this.init();\r\n\t    document.addEventListener('keyup', (event) => {\r\n\t      if (!this.canMove) {\r\n\t        return;\r\n\t      }\r\n\t      switch (event.keyCode) {\r\n\t        case 38:\r\n\t          this.moveUp();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t        case 40:\r\n\t          this.moveDown();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t        case 37:\r\n\t          this.moveLeft();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t        case 39:\r\n\t          this.moveRight();\r\n\t          this.success = this.isSuccess();\r\n\t          this.gameover = this.isGameOver();\r\n\t          break;\r\n\t      }\r\n\t    });\r\n\t  },\r\n\t  methods: {\r\n\t\t  //初始化游戏\r\n\t    init() {\r\n\t      this.numberCells.length = 0;\r\n\t      this.score = 0;\r\n\t      this.auxId = 0;\r\n\t      this.success = false;\r\n\t      this.gameover = false;\r\n\t      this.generateOneNumberCell();\r\n\t      this.generateOneNumberCell();\r\n\t    },\r\n\t\t\r\n\t\t\r\n\t\t/* 先随机生成一个2或4的数字，然后随机获得0-3的坐标值，\r\n\t\t再去判断当前生成的坐标上有没有其他格子，若有则继续随机\r\n\t\t生成直至找到一个空位，然后再push到数组中 */\r\n\t    generateOneNumberCell() {\r\n\t      if (this.isFull()) {\r\n\t        return;\r\n\t      }\r\n\t      const num = this.random24();\r\n\t      const newCell = {//创建一个上层单元格对象\r\n\t        x: this.random0123(),\r\n\t        y: this.random0123(),\r\n\t        num: num,\r\n\t        color: this.color[num],\r\n\t        id: this.auxId++,\r\n\t      };\r\n\t      let isExist = () => this.getCellByPoint({ x: newCell.x, y: newCell.y });\r\n\t      while (isExist()) {\r\n\t        newCell.x = this.random0123();\r\n\t        newCell.y = this.random0123();\r\n\t      }\r\n\t      this.numberCells.push(newCell);\r\n\t    },\r\n\t\t//随机产生2或4\r\n\t    random24() {\r\n\t      //70%概率是2\r\n\t      return Math.random() <= 0.7 ? 2 : 4;\r\n\t    },\r\n\t    random0123() {\r\n\t      return parseInt(Math.random() * 4);\r\n\t    },\r\n\t    getCellByPoint({ x, y }) {\r\n\t      return this.numberCells.find((cell) => cell.x === x && cell.y === y);\r\n\t    },\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t    getTop(cell) {\r\n\t      return `${20 + cell.y * 120}px`;\r\n\t    },\r\n\t    getLeft(cell) {\r\n\t      return `${20 + cell.x * 120}px`;\r\n\t    },\r\n\t    sortByX(a, b) {\r\n\t      return a.x - b.x;\r\n\t    },\r\n\t    sortByY(a, b) {\r\n\t      return a.y - b.y;\r\n\t    },\r\n\t    getIndexById(id) {\r\n\t      return this.numberCells.findIndex((cell) => cell.id === id);\r\n\t    },\r\n\t\t//单元格合并动画\r\n\t    animateMerge(dom) {\r\n\t      dom.animate(\r\n\t            [\r\n\t              { transform: 'scale(0)' },\r\n\t              { transform: 'scale(1.2)' },\r\n\t              { transform: 'scale(1)' },\r\n\t            ],\r\n\t            {\r\n\t              duration: 150,\r\n\t            }\r\n\t      );\r\n\t      //合并后可以接受键盘输入\r\n\t      this.canMove = true;\r\n\t    },\r\n\t    moveLeft() {\r\n\t      //一个表示可以向左移动的变量\r\n\t      let canMoveLeft = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该行的数字格\r\n\t        let row = this.numberCells\r\n\t          .filter((cell) => cell.y === i)\r\n\t          .sort(this.sortByX);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = 0; j < row.length; j++) {\r\n\t          //如果当前是第一个数字格，则其左边一定没有数字格，则直接推向最左边\r\n\t          if (j === 0) {\r\n\t            //如果已经在最左边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最左边则移动\r\n\t            if (row[j].x !== 0) {\r\n\t              row[j].x = 0;\r\n\t              canMoveLeft = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与上一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到上一格的后一列，条件是上一格的后一列不为当前格\r\n\t            if (row[j].num === row[j - 1].num && !visited) {\r\n\t              //移动当前数字格的坐标到上一数字格上\r\n\t              row[j].x = row[j - 1].x;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t              //获取当前数字格的DOM\r\n\t              let dom1 = document.querySelector(`#c${row[j].id}`);\r\n\t              //给当前数字格一个监听器，在动画结束后再更新合并后的数字格\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = row[j].num * 2;\r\n\t                  row[j - 1].num = newNum;\r\n\t                  row[j - 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${row[j - 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(row[j].id), 1);\r\n\t                  row.splice(j, 1);\r\n\t                  j--;\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              //若发生合并则表示当前可以向左移动，则表示这一格已进行合并，避免重复合并\r\n\t              canMoveLeft = true;\r\n\t              visited = true;\r\n\t\r\n\t              // const newNum = row[j].num * 2;\r\n\t              // row[j - 1].num = newNum;\r\n\t              // row[j - 1].color = this.color[newNum];\r\n\t              // this.numberCells.splice(this.getIndexById(row[j].id), 1);\r\n\t              // row.splice(j, 1);\r\n\t              // j--;\r\n\t              // canMoveLeft = true;\r\n\t              // visited = true;\r\n\t              // this.score += newNum;\r\n\t            } else {\r\n\t              if (row[j].x !== row[j - 1].x + 1) {\r\n\t                row[j].x = row[j - 1].x + 1;\r\n\t                canMoveLeft = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveLeft) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    moveRight() {\r\n\t      //一个表示可以向右移动的变量\r\n\t      let canMoveRight = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该行的数字格\r\n\t        let row = this.numberCells\r\n\t          .filter((cell) => cell.y === i)\r\n\t          .sort(this.sortByX);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = row.length - 1; j >= 0; j--) {\r\n\t          //如果当前是最后一个数字格，则其右边一定没有数字格，则直接推向最右边\r\n\t          if (j === row.length - 1) {\r\n\t            //如果已经在最右边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最右边则移动\r\n\t            if (row[j].x !== 3) {\r\n\t              row[j].x = 3;\r\n\t              canMoveRight = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与后一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到后一格的前一列，条件是后一格的前一列不为当前格\r\n\t            if (row[j].num === row[j + 1].num && !visited) {\r\n\t              row[j].x = row[j + 1].x;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t\r\n\t              let dom1 = document.querySelector(`#c${row[j].id}`);\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = row[j].num * 2;\r\n\t                  row[j + 1].num = newNum;\r\n\t                  row[j + 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${row[j + 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(row[j].id), 1);\r\n\t                  row.splice(j, 1);\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              canMoveRight = true;\r\n\t              visited = true;\r\n\t            } else {\r\n\t              if (row[j].x !== row[j + 1].x - 1) {\r\n\t                row[j].x = row[j + 1].x - 1;\r\n\t                canMoveRight = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveRight) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    moveUp() {\r\n\t      //一个表示可以向上移动的变量\r\n\t      let canMoveUp = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该列的数字格\r\n\t        let column = this.numberCells\r\n\t          .filter((cell) => cell.x === i)\r\n\t          .sort(this.sortByY);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = 0; j < column.length; j++) {\r\n\t          //如果当前是第一个数字格，则其上边一定没有数字格，则直接推向最上边\r\n\t          if (j === 0) {\r\n\t            //如果已经在最上边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最上边则移动\r\n\t            if (column[j].y !== 0) {\r\n\t              column[j].y = 0;\r\n\t              canMoveUp = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与上一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到上一格的后一行，条件是上一格的后一行不为当前格\r\n\t            if (column[j].num === column[j - 1].num && !visited) {\r\n\t              column[j].y = column[j - 1].y;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t\r\n\t              let dom1 = document.querySelector(`#c${column[j].id}`);\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = column[j].num * 2;\r\n\t                  column[j - 1].num = newNum;\r\n\t                  column[j - 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${column[j - 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(column[j].id), 1);\r\n\t                  column.splice(j, 1);\r\n\t                  j--;\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              canMoveUp = true;\r\n\t              visited = true;\r\n\t            } else {\r\n\t              if (column[j].y !== column[j - 1].y + 1) {\r\n\t                column[j].y = column[j - 1].y + 1;\r\n\t                canMoveUp = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveUp) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    moveDown() {\r\n\t      //一个表示可以向下移动的变量\r\n\t      let canMoveDown = false;\r\n\t      for (let i = 0; i < 4; i++) {\r\n\t        //按顺序获得该列的数字格\r\n\t        let column = this.numberCells\r\n\t          .filter((cell) => cell.x === i)\r\n\t          .sort(this.sortByY);\r\n\t        //一个表示上一格已经过合并的变量\r\n\t        let visited = false;\r\n\t        for (let j = column.length - 1; j >= 0; j--) {\r\n\t          //如果当前是最后一个数字格，则其下边一定没有数字格，则直接推向最下边\r\n\t          if (j === column.length - 1) {\r\n\t            //如果已经在最后边则无需变动，也不会把可以移动的变量置为true\r\n\t            //如果不在最后边则移动\r\n\t            if (column[j].y !== 3) {\r\n\t              column[j].y = 3;\r\n\t              canMoveDown = true;\r\n\t            }\r\n\t          } else {\r\n\t            //如果当前数字格与下一数字格的数字一样，则合并\r\n\t            //否则就是将其挪到下一格的前一行，条件是下一格的前一行不为当前格\r\n\t            if (column[j].num === column[j + 1].num && !visited) {\r\n\t              column[j].y = column[j + 1].y;\r\n\t              //滑动中禁止键盘输入\r\n\t              this.canMove = false;\r\n\t\r\n\t              let dom1 = document.querySelector(`#c${column[j].id}`);\r\n\t              dom1.addEventListener(\r\n\t                'transitionend',\r\n\t                () => {\r\n\t                  const newNum = column[j].num * 2;\r\n\t                  column[j + 1].num = newNum;\r\n\t                  column[j + 1].color = this.color[newNum];\r\n\t                  let dom2 = document.querySelector(`#c${column[j + 1].id}`);\r\n\t                  this.animateMerge(dom2);\r\n\t                  this.numberCells.splice(this.getIndexById(column[j].id), 1);\r\n\t                  column.splice(j, 1);\r\n\t                  this.score += newNum;\r\n\t                },\r\n\t                true\r\n\t              );\r\n\t              canMoveDown = true;\r\n\t              visited = true;\r\n\t            } else {\r\n\t              if (column[j].y !== column[j + 1].y - 1) {\r\n\t                column[j].y = column[j + 1].y - 1;\r\n\t                canMoveDown = true;\r\n\t                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\r\n\t                visited = false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      if (canMoveDown) {\r\n\t        this.generateOneNumberCell();\r\n\t      }\r\n\t    },\r\n\t    isFull() {\r\n\t      return this.numberCells.length > 15;\r\n\t    },\r\n\t    isSuccess() {\r\n\t      return !!this.numberCells.find((cell) => cell.num === 8192);\r\n\t    },\r\n\t    isGameOver() {\r\n\t      //判断是否可以移动\r\n\t      //思路是看每个格子的右边或下边的格子是否与自己的数值相等\r\n\t      //因此第四行已经经过了第三行的比较，不用再向下比较\r\n\t      //第四列的已经经过第三列的比较，不用再向右比较\r\n\t      let cannotMove = () => {\r\n\t        for (let i = 0; i < 4; i++) {\r\n\t          let row = this.numberCells\r\n\t            .filter((cell) => cell.y === i)\r\n\t            .sort(this.sortByX);\r\n\t          for (let j = 0; j < 4; j++) {\r\n\t            //除第四行外，所有格子跟下一行同一列的格子比较数值是否相等\r\n\t            if (i < 3) {\r\n\t              if (row[j].num === this.getCellByPoint({ x: j, y: i + 1 }).num) {\r\n\t                return false;\r\n\t              }\r\n\t            }\r\n\t            //除第四列外，所有格子跟同一行下一列的格子比较数值是否相等\r\n\t            if (j < 3) {\r\n\t              if (row[j].num === row[j + 1].num) {\r\n\t                return false;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        return true;\r\n\t      };\r\n\t      return this.isFull() && cannotMove();\r\n\t    },\r\n\t  },\r\n\t};\n</script>\n\n<style lang=\"css\">\r\n\t.home{\r\n\t\twidth: 500px;\r\n\t\tmargin: auto;\r\n\t}\r\n\t.header .button{\r\n\t\tdisplay: flex;\r\n\t\tjustify-content: space-between;\r\n\t}\r\n\t.init-button {\r\n\t  width: 110px;\r\n\t  padding: 10px;\r\n\t  background-color: #8f7a66;\r\n\t  color: #fff;\r\n\t  border: none;\r\n\t  border-radius: 8px;\r\n\t  cursor: pointer;\r\n\t  outline: none;\r\n\t  font-size: 16px;\r\n\t  font-weight: bold;\r\n\t  &:hover {\r\n\t    background-color: #9f8a77;\r\n\t  }\r\n\t  }\r\n\t.container{\r\n\t\t width: 500px;\r\n\t\t height: 500px;\r\n\t\t margin-top: 20px;\r\n\t\t position: relative;\r\n\t}\r\n\t.container .mask{\r\n\t\t position: absolute;\r\n\t\t top: 0;\r\n\t\t right: 0;\r\n\t\t bottom: 0;\r\n\t\t left: 0;\r\n\t\t z-index: 9999;\r\n\t\t background: rgba(238, 228, 218, 0.5);\r\n\t\t text-align: center;\r\n\t}\r\n\t.container .mask h1{\r\n\t\tfont-size: 60px;\r\n\t\tfont-weight: 700;\r\n\t\theight: 60px;\r\n\t\tline-height: 60px;\r\n\t\tmargin-top: 120px;\r\n\t\tcolor: #776e65;\r\n\t}\r\n\t.container .mask button{\r\n\t\t  margin-top: 30px;\r\n\t}\r\n\t.number-cells .number-cell{\r\n\t\ttransition: 100ms top, 100ms left;\r\n\t}\r\n\t.appear-enter-active {\r\n\t  transition: 100ms top, 100ms left;\r\n\t}\r\n\t.appear-leave-active {\r\n\t\ttransition: 100ms top, 100ms left;\r\n\t}\r\n\t@keyframes appear {\r\n\t  0% {\r\n\t    opacity: 0;\r\n\t    transform: scale(0);\r\n\t  }\r\n\t  50% {\r\n\t    opacity: 0;\r\n\t    transform: scale(0.5);\r\n\t  }\r\n\t  100% {\r\n\t    opacity: 1;\r\n\t    transform: scale(1);\r\n\t  }\r\n\t }\n</style>\n"]}]}