{"remainingRequest":"E:\\练习\\导师项目\\2048.1\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\练习\\导师项目\\2048.1\\src\\components\\content.vue?vue&type=style&index=0&id=1b41da19&lang=css&scoped=true&","dependencies":[{"path":"E:\\练习\\导师项目\\2048.1\\src\\components\\content.vue","mtime":1620737577638},{"path":"E:\\练习\\导师项目\\2048.1\\node_modules\\css-loader\\index.js","mtime":1620651791057},{"path":"E:\\练习\\导师项目\\2048.1\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":1620651837925},{"path":"E:\\练习\\导师项目\\2048.1\\node_modules\\postcss-loader\\src\\index.js","mtime":1620651841433},{"path":"E:\\练习\\导师项目\\2048.1\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1620651810122},{"path":"E:\\练习\\导师项目\\2048.1\\node_modules\\vue-loader\\lib\\index.js","mtime":1620651837901}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nheader h1{\n    margin: 0;\n    font-size: 32px;\n}\r\nheader p {\r\n    margin: 0;\r\n    margin-top: 10px;\r\n    font-size: 16px;\r\n    span {\r\n      font-weight: bold;\r\n    }\r\n}\n.init-button {\n  width: 110px;\n  padding: 10px;\n  background-color: #8f7a66;\n  color: #fff;\n  border: none;\n  border-radius: 8px;\n  cursor: pointer;\n  outline: none;\n  font-size: 16px;\n  font-weight: bold;\n}\r\n.init-button:hover{\r\n\tbackground-color: #9f8a77;\r\n}\n.container {\n  width: 405px;\n  height: 405px;\n  margin: 20px auto;\n  position: relative;\r\n  }\n.container .mask {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 9999;\n    background: rgba(238, 228, 218, 0.5);\n    text-align: center;\r\n}\n.container h1 {\n      font-size: 60px;\n      font-weight: 700;\n      height: 60px;\n      line-height: 60px;\n      margin-top: 120px;\n      color: #776e65;\r\n}\n.container button {\n      margin-top: 30px;\n}\n.number-cells .number-cell{\n      animation-fill-mode: backwards;\n      animation: appear 200ms ease-in-out;\n}\n.appear-enter-active {\n  animation: appear 100ms ease-in-out;\n}\n.appear-leave-active {\n  animation-fill-mode: backwards;\r\n  animation: appear 200ms ease-in-out;\n}\n@keyframes appear {\n  0% {\n    opacity: 0;\n    transform: scale(0);\n  }\n  50% {\n    opacity: 0;\n    transform: scale(0.5);\n  }\n  100% {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n",{"version":3,"sources":["content.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"content.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"home\">\n    <header>\n      <h1>2048</h1>\n      <button @click=\"init\" class=\"init-button\">New Game</button>\n      <p>\n        Score: <span>{{ score }}</span>\n      </p>\n    </header>\n\n    <div class=\"container\">\n      <div class=\"mask\" v-if=\"success\">\n        <h1>You win!</h1>\n        <button @click=\"init\" class=\"init-button\">Try again</button>\n      </div>\n      <div class=\"mask\" v-if=\"gameover\">\n        <h1>Game over!</h1>\n        <button @click=\"init\" class=\"init-button\">Try again</button>\n      </div>\n      <Background />\n      <div class=\"number-cells\">\n        <transition-group name=\"appear\">\n          <div\n            class=\"number-cell\"\n            v-for=\"cell of numberCells\"\n            :id=\"`c${cell.id}`\"\n            :key=\"cell.id\"\n            :style=\"\n              `\n          width: 80px;\n          height: 80px;\n          border-radius: 5px;\n          font-size: 32px;\n          font-weight: bold;\n          line-height: 80px;\n          color: #776e65;\n\n          position: absolute;\n          z-index: ${cell.num};\n          backgroundColor: ${cell.color};\n          top: ${getTop(cell)};\n          left: ${getLeft(cell)};\n          `\n            \"\n          >\n            {{ cell.num }}\n          </div>\n        </transition-group>\n      </div>\n    </div>\n  </div>\n</template>\n\n<style lang=\"css\" scoped>\nheader h1{\n    margin: 0;\n    font-size: 32px;\n}\r\nheader p {\r\n    margin: 0;\r\n    margin-top: 10px;\r\n    font-size: 16px;\r\n    span {\r\n      font-weight: bold;\r\n    }\r\n}\n.init-button {\n  width: 110px;\n  padding: 10px;\n  background-color: #8f7a66;\n  color: #fff;\n  border: none;\n  border-radius: 8px;\n  cursor: pointer;\n  outline: none;\n  font-size: 16px;\n  font-weight: bold;\n}\r\n.init-button:hover{\r\n\tbackground-color: #9f8a77;\r\n}\n.container {\n  width: 405px;\n  height: 405px;\n  margin: 20px auto;\n  position: relative;\r\n  }\n.container .mask {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 9999;\n    background: rgba(238, 228, 218, 0.5);\n    text-align: center;\r\n}\n.container h1 {\n      font-size: 60px;\n      font-weight: 700;\n      height: 60px;\n      line-height: 60px;\n      margin-top: 120px;\n      color: #776e65;\r\n}\n.container button {\n      margin-top: 30px;\n}\n.number-cells .number-cell{\n      animation-fill-mode: backwards;\n      animation: appear 200ms ease-in-out;\n}\n.appear-enter-active {\n  animation: appear 100ms ease-in-out;\n}\n.appear-leave-active {\n  animation-fill-mode: backwards;\r\n  animation: appear 200ms ease-in-out;\n}\n@keyframes appear {\n  0% {\n    opacity: 0;\n    transform: scale(0);\n  }\n  50% {\n    opacity: 0;\n    transform: scale(0.5);\n  }\n  100% {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n</style>\n\n<script>\nimport Background from '@/components/Background';\nexport default {\n  name: 'Home',\n  components: {\n    Background,\n  },\n  data() {\n    return {\n      score: 0,\n      numberCells: [],\n      color: {\n        2: '#eee4da',\n        4: '#ede0c8',\n        8: '#f2b179',\n        16: '#f59563',\n        32: '#f67c5f',\n        64: '#f65e3b',\n        128: '#edcf72',\n        256: '#edcc61',\n        512: '#0444BF',\n        1024: '#A79674',\n        2048: '#282726',\n        4096: '#280b21',\n        8192: '#281d04',\n      },\n      auxId: 0,\n      success: false,\n      gameover: false,\n      canMove: true,\n    };\n  },\n  mounted() {\n    this.init();\n    document.addEventListener('keyup', (event) => {\n      if (!this.canMove) {\n        return;\n      }\n      switch (event.key.toLocaleUpperCase()) {\n        case 'ARROWUP':\n        case 'W':\n          this.moveUp();\n          this.success = this.isSuccess();\n          this.gameover = this.isGameOver();\n          break;\n        case 'ARROWDOWN':\n        case 'S':\n          this.moveDown();\n          this.success = this.isSuccess();\n          this.gameover = this.isGameOver();\n          break;\n        case 'ARROWLEFT':\n        case 'A':\n          this.moveLeft();\n          this.success = this.isSuccess();\n          this.gameover = this.isGameOver();\n          break;\n        case 'ARROWRIGHT':\n        case 'D':\n          this.moveRight();\n          this.success = this.isSuccess();\n          this.gameover = this.isGameOver();\n          break;\n      }\n    });\n  },\n  methods: {\n    init() {\n      this.numberCells.length = 0;\n      this.score = 0;\n      this.auxId = 0;\n      this.success = false;\n      this.gameover = false;\n      this.generateOneNumberCell();\n      this.generateOneNumberCell();\n    },\n    generateOneNumberCell() {\n      if (this.isFull()) {\n        return;\n      }\n      const num = this.random24();\n      const newCell = {\n        x: this.random0123(),\n        y: this.random0123(),\n        num: num,\n        color: this.color[num],\n        id: this.auxId++,\n      };\n      let isExist = () => this.getCellByPoint({ x: newCell.x, y: newCell.y });\n      while (isExist()) {\n        newCell.x = this.random0123();\n        newCell.y = this.random0123();\n      }\n      this.numberCells.push(newCell);\n    },\n    random24() {\n      //70%概率是2\n      return Math.random() <= 0.7 ? 2 : 4;\n    },\n    random0123() {\n      return parseInt(Math.random() * 4);\n    },\n    getCellByPoint({ x, y }) {\n      return this.numberCells.find((cell) => cell.x === x && cell.y === y);\n    },\n    getTop(cell) {\n      return `${20 + cell.y * 95}px`;\n    },\n    getLeft(cell) {\n      return `${20 + cell.x * 95}px`;\n    },\n    sortByX(a, b) {\n      return a.x - b.x;\n    },\n    sortByY(a, b) {\n      return a.y - b.y;\n    },\n    getIndexById(id) {\n      return this.numberCells.findIndex((cell) => cell.id === id);\n    },\n    animateMerge(dom) {\n      dom.animate(\n        [\n          { transform: 'scale(0)' },\n          { transform: 'scale(1.2)' },\n          { transform: 'scale(1)' },\n        ],\n        {\n          duration: 150,\n        }\n      );\n      //合并后可以接受键盘输入\n      this.canMove = true;\n    },\n    moveLeft() {\n      //一个表示可以向左移动的变量\n      let canMoveLeft = false;\n      for (let i = 0; i < 4; i++) {\n        //按顺序获得该行的数字格\n        let row = this.numberCells\n          .filter((cell) => cell.y === i)\n          .sort(this.sortByX);\n        //一个表示上一格已经过合并的变量\n        let visited = false;\n        for (let j = 0; j < row.length; j++) {\n          //如果当前是第一个数字格，则其左边一定没有数字格，则直接推向最左边\n          if (j === 0) {\n            //如果已经在最左边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最左边则移动\n            if (row[j].x !== 0) {\n              row[j].x = 0;\n              canMoveLeft = true;\n            }\n          } else {\n            //如果当前数字格与上一数字格的数字一样，则合并\n            //否则就是将其挪到上一格的后一列，条件是上一格的后一列不为当前格\n            if (row[j].num === row[j - 1].num && !visited) {\n              //移动当前数字格的坐标到上一数字格上\n              row[j].x = row[j - 1].x;\n              //滑动中禁止键盘输入\n              this.canMove = false;\n              //获取当前数字格的DOM\n              let dom1 = document.querySelector(`#c${row[j].id}`);\n              //给当前数字格一个监听器，在动画结束后再更新合并后的数字格\n              dom1.addEventListener(\n                'transitionend',\n                () => {\n                  const newNum = row[j].num * 2;\n                  row[j - 1].num = newNum;\n                  row[j - 1].color = this.color[newNum];\n                  let dom2 = document.querySelector(`#c${row[j - 1].id}`);\n                  this.animateMerge(dom2);\n                  this.numberCells.splice(this.getIndexById(row[j].id), 1);\n                  row.splice(j, 1);\n                  j--;\n                  this.score += newNum;\n                },\n                true\n              );\n              //若发生合并则表示当前可以向左移动，则表示这一格已进行合并，避免重复合并\n              canMoveLeft = true;\n              visited = true;\n\n              // const newNum = row[j].num * 2;\n              // row[j - 1].num = newNum;\n              // row[j - 1].color = this.color[newNum];\n              // this.numberCells.splice(this.getIndexById(row[j].id), 1);\n              // row.splice(j, 1);\n              // j--;\n              // canMoveLeft = true;\n              // visited = true;\n              // this.score += newNum;\n            } else {\n              if (row[j].x !== row[j - 1].x + 1) {\n                row[j].x = row[j - 1].x + 1;\n                canMoveLeft = true;\n                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n                visited = false;\n              }\n            }\n          }\n        }\n      }\n      if (canMoveLeft) {\n        this.generateOneNumberCell();\n      }\n    },\n    moveRight() {\n      //一个表示可以向右移动的变量\n      let canMoveRight = false;\n      for (let i = 0; i < 4; i++) {\n        //按顺序获得该行的数字格\n        let row = this.numberCells\n          .filter((cell) => cell.y === i)\n          .sort(this.sortByX);\n        //一个表示上一格已经过合并的变量\n        let visited = false;\n        for (let j = row.length - 1; j >= 0; j--) {\n          //如果当前是最后一个数字格，则其右边一定没有数字格，则直接推向最右边\n          if (j === row.length - 1) {\n            //如果已经在最右边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最右边则移动\n            if (row[j].x !== 3) {\n              row[j].x = 3;\n              canMoveRight = true;\n            }\n          } else {\n            //如果当前数字格与后一数字格的数字一样，则合并\n            //否则就是将其挪到后一格的前一列，条件是后一格的前一列不为当前格\n            if (row[j].num === row[j + 1].num && !visited) {\n              row[j].x = row[j + 1].x;\n              //滑动中禁止键盘输入\n              this.canMove = false;\n\n              let dom1 = document.querySelector(`#c${row[j].id}`);\n              dom1.addEventListener(\n                'transitionend',\n                () => {\n                  const newNum = row[j].num * 2;\n                  row[j + 1].num = newNum;\n                  row[j + 1].color = this.color[newNum];\n                  let dom2 = document.querySelector(`#c${row[j + 1].id}`);\n                  this.animateMerge(dom2);\n                  this.numberCells.splice(this.getIndexById(row[j].id), 1);\n                  row.splice(j, 1);\n                  this.score += newNum;\n                },\n                true\n              );\n              canMoveRight = true;\n              visited = true;\n            } else {\n              if (row[j].x !== row[j + 1].x - 1) {\n                row[j].x = row[j + 1].x - 1;\n                canMoveRight = true;\n                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n                visited = false;\n              }\n            }\n          }\n        }\n      }\n      if (canMoveRight) {\n        this.generateOneNumberCell();\n      }\n    },\n    moveUp() {\n      //一个表示可以向上移动的变量\n      let canMoveUp = false;\n      for (let i = 0; i < 4; i++) {\n        //按顺序获得该列的数字格\n        let column = this.numberCells\n          .filter((cell) => cell.x === i)\n          .sort(this.sortByY);\n        //一个表示上一格已经过合并的变量\n        let visited = false;\n        for (let j = 0; j < column.length; j++) {\n          //如果当前是第一个数字格，则其上边一定没有数字格，则直接推向最上边\n          if (j === 0) {\n            //如果已经在最上边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最上边则移动\n            if (column[j].y !== 0) {\n              column[j].y = 0;\n              canMoveUp = true;\n            }\n          } else {\n            //如果当前数字格与上一数字格的数字一样，则合并\n            //否则就是将其挪到上一格的后一行，条件是上一格的后一行不为当前格\n            if (column[j].num === column[j - 1].num && !visited) {\n              column[j].y = column[j - 1].y;\n              //滑动中禁止键盘输入\n              this.canMove = false;\n\n              let dom1 = document.querySelector(`#c${column[j].id}`);\n              dom1.addEventListener(\n                'transitionend',\n                () => {\n                  const newNum = column[j].num * 2;\n                  column[j - 1].num = newNum;\n                  column[j - 1].color = this.color[newNum];\n                  let dom2 = document.querySelector(`#c${column[j - 1].id}`);\n                  this.animateMerge(dom2);\n                  this.numberCells.splice(this.getIndexById(column[j].id), 1);\n                  column.splice(j, 1);\n                  j--;\n                  this.score += newNum;\n                },\n                true\n              );\n              canMoveUp = true;\n              visited = true;\n            } else {\n              if (column[j].y !== column[j - 1].y + 1) {\n                column[j].y = column[j - 1].y + 1;\n                canMoveUp = true;\n                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n                visited = false;\n              }\n            }\n          }\n        }\n      }\n      if (canMoveUp) {\n        this.generateOneNumberCell();\n      }\n    },\n    moveDown() {\n      //一个表示可以向下移动的变量\n      let canMoveDown = false;\n      for (let i = 0; i < 4; i++) {\n        //按顺序获得该列的数字格\n        let column = this.numberCells\n          .filter((cell) => cell.x === i)\n          .sort(this.sortByY);\n        //一个表示上一格已经过合并的变量\n        let visited = false;\n        for (let j = column.length - 1; j >= 0; j--) {\n          //如果当前是最后一个数字格，则其下边一定没有数字格，则直接推向最下边\n          if (j === column.length - 1) {\n            //如果已经在最后边则无需变动，也不会把可以移动的变量置为true\n            //如果不在最后边则移动\n            if (column[j].y !== 3) {\n              column[j].y = 3;\n              canMoveDown = true;\n            }\n          } else {\n            //如果当前数字格与下一数字格的数字一样，则合并\n            //否则就是将其挪到下一格的前一行，条件是下一格的前一行不为当前格\n            if (column[j].num === column[j + 1].num && !visited) {\n              column[j].y = column[j + 1].y;\n              //滑动中禁止键盘输入\n              this.canMove = false;\n\n              let dom1 = document.querySelector(`#c${column[j].id}`);\n              dom1.addEventListener(\n                'transitionend',\n                () => {\n                  const newNum = column[j].num * 2;\n                  column[j + 1].num = newNum;\n                  column[j + 1].color = this.color[newNum];\n                  let dom2 = document.querySelector(`#c${column[j + 1].id}`);\n                  this.animateMerge(dom2);\n                  this.numberCells.splice(this.getIndexById(column[j].id), 1);\n                  column.splice(j, 1);\n                  this.score += newNum;\n                },\n                true\n              );\n              canMoveDown = true;\n              visited = true;\n            } else {\n              if (column[j].y !== column[j + 1].y - 1) {\n                column[j].y = column[j + 1].y - 1;\n                canMoveDown = true;\n                //如果进行一次无合并的移动，则表示上一格（这一格）没进行合并\n                visited = false;\n              }\n            }\n          }\n        }\n      }\n      if (canMoveDown) {\n        this.generateOneNumberCell();\n      }\n    },\n    isFull() {\n      return this.numberCells.length > 15;\n    },\n    isSuccess() {\n      return !!this.numberCells.find((cell) => cell.num === 8192);\n    },\n    isGameOver() {\n      //判断是否可以移动\n      //思路是看每个格子的右边或下边的格子是否与自己的数值相等\n      //因此第四行已经经过了第三行的比较，不用再向下比较\n      //第四列的已经经过第三列的比较，不用再向右比较\n      let cannotMove = () => {\n        for (let i = 0; i < 4; i++) {\n          let row = this.numberCells\n            .filter((cell) => cell.y === i)\n            .sort(this.sortByX);\n          for (let j = 0; j < 4; j++) {\n            //除第四行外，所有格子跟下一行同一列的格子比较数值是否相等\n            if (i < 3) {\n              if (row[j].num === this.getCellByPoint({ x: j, y: i + 1 }).num) {\n                return false;\n              }\n            }\n            //除第四列外，所有格子跟同一行下一列的格子比较数值是否相等\n            if (j < 3) {\n              if (row[j].num === row[j + 1].num) {\n                return false;\n              }\n            }\n          }\n        }\n        return true;\n      };\n      return this.isFull() && cannotMove();\n    },\n  },\n};\n</script>\n"]}]}